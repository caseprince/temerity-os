
const unsigned char eyes []PROGMEM = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x7f, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xc0,
  0x1, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xf0,
  0x3, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xfc,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xfc,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0,
  0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0,
  0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0,
  0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0,
  0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0,
  0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0
};

// DOTSTARs
#include <Adafruit_DotStar.h>
#include <SPI.h>
#define NUMPIXELS 288 // Number of dotstars
#define DATAPIN    3
#define CLOCKPIN   2
Adafruit_DotStar dotstars(NUMPIXELS, DATAPIN, CLOCKPIN, DOTSTAR_BRG);
// Hardware SPI is a little faster, but must be wired to specific pins
// (Arduino Uno = pin 11 for data, 13 for clock, other boards are different).
//Adafruit_DotStar dotstars(NUMPIXELS, DOTSTAR_BRG);
uint32_t dotstarHueOffset = 0;

// Basic demo for accelerometer readings from Adafruit MSA301
#include <Wire.h>
#include <Adafruit_MSA301.h>
#include <Adafruit_Sensor.h>
Adafruit_MSA301 msa;


/* This example shows basic usage of the NeoTrellis.
  The buttons will light up various colors when pressed.
  The interrupt pin is not used in this example.
*/

#include <Adafruit_GFX.h>    // Core graphics library
#include <Adafruit_ST7789.h> // Hardware-specific library for ST7789
#include <SPI.h>

#define TFT_CS        44 // PyBadge/PyGamer display control pins: chip select
#define TFT_RST       46 // Display reset
#define TFT_DC        45 // Display data/command select
#define TFT_BACKLIGHT 47 // Display backlight pin

// OPTION 1 (recommended) is to use the HARDWARE SPI pins, which are unique
// to each board and not reassignable.
Adafruit_ST7789 tft = Adafruit_ST7789(&SPI1, TFT_CS, TFT_DC, TFT_RST);

#include "Adafruit_NeoTrellis.h"
Adafruit_NeoTrellis trellis;

// NeoPXL8 8 x 20
#include <Adafruit_NeoPXL8.h>
#define NUM_LED 20  // Per strand. Total number of pixels is 8X this!
// Here's a pinout that works with the Feather M4 (w/NeoPXL8 M4 FeatherWing):
int8_t pins[8] = { 13, 12, 11, 10, SCK, 5, 9, 6 };
// Alternates are available for the last 4 pins:
//int8_t pins[8] = { 13, 12, 11, 10, PIN_SERIAL1_RX, PIN_SERIAL1_TX, SCL, SDA };
Adafruit_NeoPXL8 leds(NUM_LED, pins, NEO_GRB);

Adafruit_NeoPixel onboard_leds(4, 8, NEO_GRB + NEO_KHZ800);


// RGBW LEDs

// Which pin on the Arduino is connected to the NeoPixels?
// On a Trinket or Gemma we suggest changing this to 1:
#define LED_PIN    3

// How many NeoPixels are attached to the Arduino?
#define LED_COUNT 60

// Declare our NeoPixel strip object:
Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_RGBW);
// Argument 1 = Number of pixels in NeoPixel strip
// Argument 2 = Arduino pin number (most are valid)
// Argument 3 = Pixel type flags, add together as needed:
//   NEO_KHZ800  800 KHz bitstream (most NeoPixel products w/WS2812 LEDs)
//   NEO_KHZ400  400 KHz (classic 'v1' (not v2) FLORA pixels, WS2811 drivers)
//   NEO_GRB     Pixels are wired for GRB bitstream (most NeoPixel products)
//   NEO_RGB     Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2)
//   NEO_RGBW    Pixels are wired for RGBW bitstream (NeoPixel RGBW products)



// Custom colors
#define ST77XX_ORANGE_YEL 0xFDC0
#define ST77XX_ORANGE_RED 0xFB80
#define ST77XX_ORANGE_DK 0xA240

// Ring buffer for console output
uint8_t consoleLines = 8;
String consoleBuffer[8];
uint8_t consolePointer = 0;
void drawConsole(String string) {
  consoleBuffer[consolePointer] = string;
  consolePointer = (consolePointer + 1) % 8;
  tft.setCursor(0, 30);
  tft.setTextSize(2);
  tft.setTextWrap(false);
  tft.setTextColor(ST77XX_ORANGE, ST77XX_BLACK);
  for (uint16_t i = 0; i < 8; i++) {
    tft.println(consoleBuffer[(i + consolePointer) % 8] + "                    "); // Dumb right pad
  }
}


// define a callback for key presses
uint8_t lastPressed = 0;
boolean isDown[16];
uint8_t brightness = 127;
TrellisCallback blink(keyEvent evt) {
  // Check is the pad pressed?
  if (evt.bit.EDGE == SEESAW_KEYPAD_EDGE_RISING) {
    trellis.pixels.setPixelColor(evt.bit.NUM, Wheel(map(evt.bit.NUM, 0, trellis.pixels.numPixels(), 0, 255))); //on rising

    if (evt.bit.NUM == 3) {
      if (brightness < 255) {
        brightness += 16;
        leds.setBrightness(brightness);
        drawConsole("Brightness " + String(brightness));
      }
    } else if (evt.bit.NUM == 7) {
      if (brightness > 16) {
        brightness -= 16;
        leds.setBrightness(brightness);
        drawConsole("Brightness " + String(brightness));
      }
    } else if (evt.bit.NUM == 15) {
    } else {
      drawConsole("Press " + String(evt.bit.NUM));
      lastPressed = evt.bit.NUM;
    }
    isDown[evt.bit.NUM] = true;
  } else if (evt.bit.EDGE == SEESAW_KEYPAD_EDGE_FALLING) {
    // or is the pad released?
    isDown[evt.bit.NUM] = false;
    trellis.pixels.setPixelColor(evt.bit.NUM, 0); //off falling
  }

  // Turn on/off the neopixels!
  trellis.pixels.show();

  return 0;
}

uint8_t sparkles_r[8 * NUM_LED];
uint8_t sparkles_g[8 * NUM_LED];
uint8_t sparkles_b[8 * NUM_LED];
void setup() {
  Serial.begin(9600);
  // while(!Serial);
  onboard_leds.begin();
  onboard_leds.setPixelColor(0, 70, 30, 0);
  onboard_leds.setPixelColor(1, 70, 30, 0);
  onboard_leds.setPixelColor(2, 70, 30, 0);
  onboard_leds.setPixelColor(3, 70, 30, 0);
  onboard_leds.setBrightness(64);
  onboard_leds.show(); // Initialize all pixels to 'off'

  for (uint16_t i = 0; i < sizeof(sparkles_r); i++) {
    sparkles_r[i] = uint8_t(random(255));
    sparkles_g[i] = uint8_t(random(255));
    sparkles_b[i] = uint8_t(random(255));
  }

  if (!trellis.begin()) {
    Serial.println("Could not start trellis, check wiring?");
    while (1);
  } else {
    Serial.println("NeoPixel Trellis started");
  }

  //activate all keys and set callbacks
  for (int i = 0; i < NEO_TRELLIS_NUM_KEYS; i++) {
    trellis.activateKey(i, SEESAW_KEYPAD_EDGE_RISING);
    trellis.activateKey(i, SEESAW_KEYPAD_EDGE_FALLING);
    trellis.registerCallback(i, blink);
  }

  // SCREEN
  tft.init(240, 240);                // Initialize ST7789 screen
  pinMode(TFT_BACKLIGHT, OUTPUT);
  digitalWrite(TFT_BACKLIGHT, HIGH); // Backlight on

  Serial.println(F("Initialized"));

  uint16_t time = millis();
  tft.fillScreen(ST77XX_BLACK);
  time = millis() - time;

  Serial.println(time, DEC);


  // large block of text
  tft.fillScreen(ST77XX_BLACK);
  testdrawtext("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur adipiscing ante sed nibh tincidunt feugiat. Maecenas enim massa, fringilla sed malesuada et, malesuada sit amet turpis. Sed porttitor neque ut ante pretium vitae malesuada nunc bibendum. Nullam aliquet ultrices massa eu hendrerit. Ut sed nisi lorem. In vestibulum purus a tortor imperdiet posuere. ", ST77XX_WHITE);
  tft.fillScreen(ST77XX_BLACK);

  tft.setCursor(0, 0);
  tft.setTextColor(ST77XX_ORANGE_YEL, ST77XX_BLACK);
  tft.print("Temerity OS v1.0.2");

  tft.drawBitmap(0, 176, eyes, 240, 64, ST77XX_ORANGE_RED);

  // do a little animation to show we're on
  for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
    trellis.pixels.setPixelColor(i, TrellisWheel(map(i, 0, trellis.pixels.numPixels(), 0, 255)));
    trellis.pixels.show();
    delay(10);
  }
  for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
    trellis.pixels.setPixelColor(i, 0x000000);
    trellis.pixels.show();
    delay(10);
  }

  drawConsole("Temerity OS v1.0.1");
  drawConsole("System ready");
  char lv[] = {char(0xCC), char(0xCC)};
  drawConsole(lv);

  pinMode(13, OUTPUT);


  leds.begin();
  leds.setBrightness(brightness);

  strip.begin();
  strip.setPixelColor(6, 100, 100, 100, 127);
  strip.setPixelColor(7, 0, 0, 0, 127);
  strip.setPixelColor(8, 100, 0, 190, 127);
  strip.show(); // Initialize all pixels to 'off'


  dotstars.begin(); // Initialize pins for output
  dotstars.setBrightness(32);
  dotstars.show();  // Turn all LEDs off ASAP


  // Try to initialize MSA301
  if (! msa.begin()) {
    Serial.println("Failed to find MSA301 chip");
    while (1) {
      delay(10);
    }
  }
  Serial.println("MSA301 Found!");
  //msa.setDataRate(MSA301_DATARATE_31_25_HZ);
  Serial.print("Data rate set to: ");
  switch (msa.getDataRate()) {
    case MSA301_DATARATE_1_HZ: Serial.println("1 Hz"); break;
    case MSA301_DATARATE_1_95_HZ: Serial.println("1.95 Hz"); break;
    case MSA301_DATARATE_3_9_HZ: Serial.println("3.9 Hz"); break;
    case MSA301_DATARATE_7_81_HZ: Serial.println("7.81 Hz"); break;
    case MSA301_DATARATE_15_63_HZ: Serial.println("15.63 Hz"); break;
    case MSA301_DATARATE_31_25_HZ: Serial.println("31.25 Hz"); break;
    case MSA301_DATARATE_62_5_HZ: Serial.println("62.5 Hz"); break;
    case MSA301_DATARATE_125_HZ: Serial.println("125 Hz"); break;
    case MSA301_DATARATE_250_HZ: Serial.println("250 Hz"); break;
    case MSA301_DATARATE_500_HZ: Serial.println("500 Hz"); break;
    case MSA301_DATARATE_1000_HZ: Serial.println("1000 Hz"); break;
  }

  //msa.setPowerMode(MSA301_SUSPENDMODE);
  Serial.print("Power mode set to: ");
  switch (msa.getPowerMode()) {
    case MSA301_NORMALMODE: Serial.println("Normal"); break;
    case MSA301_LOWPOWERMODE: Serial.println("Low Power"); break;
    case MSA301_SUSPENDMODE: Serial.println("Suspend"); break;
  }

  //msa.setBandwidth(MSA301_BANDWIDTH_31_25_HZ);
  Serial.print("Bandwidth set to: ");
  switch (msa.getBandwidth()) {
    case MSA301_BANDWIDTH_1_95_HZ: Serial.println("1.95 Hz"); break;
    case MSA301_BANDWIDTH_3_9_HZ: Serial.println("3.9 Hz"); break;
    case MSA301_BANDWIDTH_7_81_HZ: Serial.println("7.81 Hz"); break;
    case MSA301_BANDWIDTH_15_63_HZ: Serial.println("15.63 Hz"); break;
    case MSA301_BANDWIDTH_31_25_HZ: Serial.println("31.25 Hz"); break;
    case MSA301_BANDWIDTH_62_5_HZ: Serial.println("62.5 Hz"); break;
    case MSA301_BANDWIDTH_125_HZ: Serial.println("125 Hz"); break;
    case MSA301_BANDWIDTH_250_HZ: Serial.println("250 Hz"); break;
    case MSA301_BANDWIDTH_500_HZ: Serial.println("500 Hz"); break;
  }

  //msa.setRange(MSA301_RANGE_2_G);
  Serial.print("Range set to: ");
  switch (msa.getRange()) {
    case MSA301_RANGE_2_G: Serial.println("+-2G"); break;
    case MSA301_RANGE_4_G: Serial.println("+-4G"); break;
    case MSA301_RANGE_8_G: Serial.println("+-8G"); break;
    case MSA301_RANGE_16_G: Serial.println("+-16G"); break;
  }

  //msa.setResolution(MSA301_RESOLUTION_14 );
  Serial.print("Resolution set to: ");
  switch (msa.getResolution()) {
    case MSA301_RESOLUTION_14: Serial.println("14 bits"); break;
    case MSA301_RESOLUTION_12: Serial.println("12 bits"); break;
    case MSA301_RESOLUTION_10: Serial.println("10 bits"); break;
    case MSA301_RESOLUTION_8: Serial.println("8 bits"); break;
  }
}

uint16_t frame = 0;
uint16_t millis_last = 0;
uint16_t sine_offset = 0;
float sine_ms = 10000;
uint16_t cylon = 0;

uint32_t sine_r = 0;
float sine_r_ms = 12000;
uint32_t sine_g = 0;
float sine_g_ms = 9000;
uint32_t sine_b = 0;
float sine_b_ms = 23000;

int16_t cylonX = 0;
int16_t cylonY = 0;
int16_t cylonXV = 2;
int16_t cylonYV = 1;

void loop() {
  trellis.read();  // interrupt management does all the work! :)
  uint16_t ms_elapsed = millis() - millis_last;

    // DOTSTARs
  for (uint16_t i = 0; i < dotstars.numPixels(); i++) {
    uint32_t rgbcolor = dotstars.ColorHSV(dotstarHueOffset + (i * 1000), 255, 55);
    dotstars.setPixelColor(i, rgbcolor);
    dotstarHueOffset += 10;
    //tft.drawPixel(0, i + 30, tft.color565((rgbcolor & 0xff000000) >> 24, (rgbcolor & 0x00ff0000) >> 16, (rgbcolor & 0x0000ff00) >> 8));

    //uint32_t rgbcolorDisplay = dotstars.ColorHSV(dotstarHueOffset + (i * 1000), 255, 255);
    //tft.drawPixel(0, i + 30, tft.color565(getRedValueFromColor(rgbcolorDisplay), getGreenValueFromColor(rgbcolorDisplay), getBlueValueFromColor(rgbcolorDisplay)));
  }
  dotstars.show();

  // ONBOARD and TRELLIS
  if (lastPressed == 0) {
    // RAINBOWS
    onboard_leds.setPixelColor(0, Wheel(((millis() / 200) + 0) * 3.5));
    onboard_leds.setPixelColor(1, Wheel(((millis() / 200) + 10) * 3.5));
    onboard_leds.setPixelColor(2, Wheel(((millis() / 200) + 20) * 3.5));
    onboard_leds.setPixelColor(3, Wheel(((millis() / 200) + 30) * 3.5));
    trellis.pixels.setBrightness(50);
    for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
      trellis.pixels.setPixelColor(i, Wheel(((millis() / 200.0) + i) * 3.5));
    }

    cylonX = 0;
    cylonY = 0;
    cylonXV = 2;
    cylonYV = 1;
  } else if (lastPressed == 1) {
    // Orange sine
    onboard_leds.setPixelColor(0, leds.Color(255, 50 + (sin((sine_offset / sine_ms) + 10) * 100), 0));
    onboard_leds.setPixelColor(1, leds.Color(255, 50 + (sin((sine_offset / sine_ms) + 20) * 100), 0));
    onboard_leds.setPixelColor(2, leds.Color(255, 50 + (sin((sine_offset / sine_ms) + 30) * 100), 0));
    onboard_leds.setPixelColor(3, leds.Color(255, 50 + (sin((sine_offset / sine_ms) + 40) * 100), 0));
    for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
      trellis.pixels.setPixelColor(i, 0, 0, 0);
    }
  } else if (lastPressed == 2) {
    // Sparkle Party!
    onboard_leds.setPixelColor(0, leds.Color(sparkles_r[0], sparkles_g[0], sparkles_b[0]));
    onboard_leds.setPixelColor(1, leds.Color(sparkles_r[1], sparkles_g[1], sparkles_b[1]));
    onboard_leds.setPixelColor(2, leds.Color(sparkles_r[2], sparkles_g[2], sparkles_b[2]));
    onboard_leds.setPixelColor(3, leds.Color(sparkles_r[3], sparkles_g[3], sparkles_b[3]));
    for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
       trellis.pixels.setPixelColor(i, leds.Color(sparkles_r[i+5], sparkles_g[i+5], sparkles_b[i+5]));
    }
  } else if (lastPressed == 4){
    // Pink sine
    onboard_leds.setPixelColor(0, leds.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + 10) * 100)));
    onboard_leds.setPixelColor(1, leds.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + 20) * 100)));
    onboard_leds.setPixelColor(2, leds.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + 30) * 100)));
    onboard_leds.setPixelColor(3, leds.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + 40) * 100)));
  } else if (lastPressed == 5) {
    // Blue Green sine
    onboard_leds.setPixelColor(0, leds.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + 10) * 100)));
    onboard_leds.setPixelColor(1, leds.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + 20) * 100)));
    onboard_leds.setPixelColor(2, leds.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + 30) * 100)));
    onboard_leds.setPixelColor(3, leds.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + 40) * 100)));
  } else if (lastPressed == 6) {
    // cylon
    onboard_leds.setPixelColor(0, leds.Color(255, 0, 0));
    onboard_leds.setPixelColor(1, leds.Color(255, 0, 0));
    onboard_leds.setPixelColor(2, leds.Color(255, 0, 0));
    onboard_leds.setPixelColor(3, leds.Color(255, 0, 0));
    for (uint16_t x = 0; x < 4; x++) {
      for (uint16_t y = 0; y < 4; y++) {
        uint16_t i = (y * 4) + x;
        if (x == cylonX && y == cylonY) {
          trellis.pixels.setPixelColor(i, leds.Color(255, 0, 0));
        } else {
          trellis.pixels.setPixelColor(i, leds.Color(0, 0, 0));
        }
      }
    }

    // SNAAAAAAKE
    cylonX += floor(cylonXV / 2);
    cylonY += floor(cylonYV / 2);
    if (cylonX > 3) {
      if (cylonY == 0) { // turn 3
        cylonXV = -1;
        cylonYV = -2;
        cylonX = 3;
        cylonY = 1;
      } else {
        cylonXV = -cylonXV;
        cylonY += cylonYV;
      }
    }
    if (cylonX < 0) {
      if (cylonY == 3) { // turn 1
        cylonXV = -1;
        cylonYV = -2;
        cylonX = 0;
        cylonY = 2;
      } else {
        cylonXV = -cylonXV;
        cylonY += cylonYV;
      }
    }
    if (cylonY > 3) {
      if (cylonX == 3) { // turn 2
        cylonXV = -2;
        cylonYV = -1;
        cylonX = 2;
        cylonY = 3;
      } else {
        cylonYV = -cylonYV;
        cylonX += cylonXV;
      }
    }
    if (cylonY < 0 ) {
      if (cylonX == 0) { // turn 4
        cylonXV = 2;
        cylonYV = 1;
        cylonX = 1;
        cylonY = 0;
      } else {
        cylonYV = -cylonYV;
        cylonX += cylonXV;
      }
    }
  } else {
    // OFF by default
    for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
      onboard_leds.setPixelColor(0, 70, 30, 0);
      onboard_leds.setPixelColor(1, 70, 30, 0);
      onboard_leds.setPixelColor(2, 70, 30, 0);
      onboard_leds.setPixelColor(3, 70, 30, 0);
      trellis.pixels.setPixelColor(i, 0, 0, 0);
    }
  }
  onboard_leds.show();
  trellis.pixels.show();


  // RGBW
//  for (uint8_t i = 10; i < 20; i++) { // For each strand...
//    strip.setPixelColor(i, Wheel(((millis() / 200) + i) * 3.5));
//  }
  strip.show();


  // NEON
  for (uint8_t r = 0; r < 8; r++) { // For each strand...
    for (int p = 0; p < NUM_LED; p++) { // For each pixel of strand...
      //leds.setPixelColor(r * NUM_LED + p, rain(r, p));
      uint8_t pn = r * NUM_LED + p;
      if (lastPressed == 0) {
        // RAINBOWS
        leds.setPixelColor(r * NUM_LED + p, Wheel(((millis() / 200) + pn) * 3.5));
      } else if (lastPressed == 1) {
        // Orange sine
        // leds.setPixelColor(r * NUM_LED + p, leds.Color(255, 110, 0));
        leds.setPixelColor(r * NUM_LED + p, leds.Color(255, 50 + (sin((sine_offset / sine_ms) + (pn / 2.0)) * 100), 0));
        sine_offset += ms_elapsed;
        if (sine_offset > TWO_PI * sine_ms) {
          sine_offset -= TWO_PI * sine_ms;
        }
      } else if (lastPressed == 2) {
        // Sparkle Party!
        if (random(1000) < ms_elapsed) {
          sparkles_r[pn] = uint8_t(random(255));
          sparkles_g[pn] = uint8_t(random(255));
          sparkles_b[pn] = uint8_t(random(255));
        }
        leds.setPixelColor(r * NUM_LED + p, leds.Color(sparkles_r[pn], sparkles_g[pn], sparkles_b[pn]));
      } else if (lastPressed == 4) {
        // Pink sine
        leds.setPixelColor(r * NUM_LED + p, leds.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + (pn)) * 100)));
        sine_offset += ms_elapsed;
        if (sine_offset > TWO_PI * sine_ms) {
          sine_offset -= TWO_PI * sine_ms;
        }

      } else if (lastPressed == 5) {
        // Blue Green sine
        leds.setPixelColor(r * NUM_LED + p, leds.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + (pn)) * 100)));
        sine_offset += ms_elapsed;
        if (sine_offset > TWO_PI * sine_ms) {
          sine_offset -= TWO_PI * sine_ms;
        }
      } else if (lastPressed == 6) {
        // cylon
        if (pn == cylon) {
          leds.setPixelColor(r * NUM_LED + p, leds.Color(255, 0, 0));
        } else {
          leds.setPixelColor(r * NUM_LED + p, leds.Color(0, 0, 0));
        }
      } else if (lastPressed == 8) {
        // RGB sine waves
        sine_r += ms_elapsed / 8.0;
        sine_g += ms_elapsed / 7.0;
        sine_b += ms_elapsed / 6.0;
        if (sine_r > TWO_PI * sine_r_ms) {
          sine_r -= TWO_PI * sine_r_ms;
        }
        if (sine_g > TWO_PI * sine_g_ms) {
          sine_g -= TWO_PI * sine_g_ms;
        }
        if (sine_b > TWO_PI * sine_b_ms) {
          sine_b -= TWO_PI * sine_b_ms;
        }
        leds.setPixelColor(r * NUM_LED + p, leds.Color(sin((sine_r / sine_r_ms) + (pn / 4.0)) * 255, sin((sine_g / sine_g_ms) + (pn / 3.0)) * 255, sin((sine_b / sine_b_ms) - (pn / 5.0)) * 255));
      } else {
        // RAINBOWS by default
        // leds.setPixelColor(r * NUM_LED + p, Wheel((frame/100  + p)*3));
        leds.setPixelColor(r * NUM_LED + p, Wheel(((millis() / 200) + pn) * 3.5));
      }
      if (isDown[15]) {
        leds.setPixelColor(r * NUM_LED + p, leds.Color(255, 255, 255));
      }
    }
  }


  /* Display the results (acceleration is measured in m/s^2) */
  sensors_event_t event;
  msa.getEvent(&event);
  tft.setTextSize(2);
  tft.setCursor(0, 10);
  tft.setTextColor(ST77XX_ORANGE_DK, ST77XX_BLACK);
  tft.print("x");
  tft.setTextColor(ST77XX_ORANGE_RED, ST77XX_BLACK);
  tft.print(event.acceleration.x);

  tft.setCursor(80, 10);
  tft.setTextColor(ST77XX_ORANGE_DK, ST77XX_BLACK);
  tft.print("y");
  tft.setTextColor(ST77XX_ORANGE_RED, ST77XX_BLACK);
  tft.print(event.acceleration.y);

  tft.setCursor(160, 10);
  tft.setTextColor(ST77XX_ORANGE_DK, ST77XX_BLACK);
  tft.print("z");
  tft.setTextColor(ST77XX_ORANGE_RED, ST77XX_BLACK);
  tft.print(event.acceleration.z);

  cylon += 1;
  if (cylon > NUM_LED * 8) {
    cylon = 0;
  }

  float fade = ms_elapsed / 4.0;
  for (uint16_t i = 0; i < sizeof(sparkles_r); i++) {
    if (sparkles_r[i] - fade > 0) {
      sparkles_r[i] -= fade;
    } else {
      sparkles_r[i] = 0;
    }
    if (sparkles_g[i] - fade > 0) {
      sparkles_g[i] -= fade;
    } else {
      sparkles_g[i] = 0;
    }
    if (sparkles_b[i] - fade > 0) {
      sparkles_b[i] -= fade;
    } else {
      sparkles_b[i] = 0;
    }
  }


  leds.show();
  frame++;
  if (frame > 65535) {
    frame = 0;
  }

  millis_last = millis();
  delay(20); // the trellis has a resolution of around 60hz
}


uint32_t Wheel(byte WheelPos)
{
  WheelPos = 255 - (WheelPos % 255);
  if (WheelPos < 85)
  {
    return leds.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  }
  else if (WheelPos < 170)
  {
    WheelPos -= 85;
    return leds.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  }
  else
  {
    WheelPos -= 170;
    return leds.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
  }
}

void testdrawtext(char *text, uint16_t color) {
  tft.setCursor(0, 0);
  tft.setTextColor(color);
  tft.setTextWrap(true);
  tft.print(text);
}


/******************************************/

// Input a value 0 to 255 to get a color value.
// The colors are a transition r - g - b - back to r.
uint32_t TrellisWheel(byte WheelPos) {
  if (WheelPos < 85) {
    return trellis.pixels.Color(WheelPos * 3, 55 - WheelPos * 3, 0);
  } else if (WheelPos < 170) {
    WheelPos -= 85;
    return trellis.pixels.Color(55 - WheelPos * 3, 0, WheelPos * 3);
  } else {
    WheelPos -= 170;
    return trellis.pixels.Color(0, WheelPos * 3, 55 - WheelPos * 3);
  }
  return 0;
}
