
const unsigned char eyes []PROGMEM = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x7f, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xc0,
  0x1, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xf0,
  0x3, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xfc,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xfc,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0,
  0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0,
  0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0,
  0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0,
  0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0,
  0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0
};

#include "Adafruit_NeoTrellis.h"

// Onboard Screen
#include <Adafruit_GFX.h>    // Core graphics library
#include <Adafruit_ST7789.h> // Hardware-specific library for ST7789
#include <SPI.h>
#define TFT_CS        44 // PyBadge/PyGamer display control pins: chip select
#define TFT_RST       46 // Display reset
#define TFT_DC        45 // Display data/command select
#define TFT_BACKLIGHT 47 // Display backlight pin
Adafruit_ST7789 tft = Adafruit_ST7789(&SPI1, TFT_CS, TFT_DC, TFT_RST);
// Custom colors
#define ST77XX_ORANGE_YEL 0xFDC0
#define ST77XX_ORANGE_RED 0xFB80
#define ST77XX_ORANGE_DK 0xA240

// NeoPXL8 8 x 20
#include <Adafruit_NeoPXL8.h>
#define NUM_LED 20  // Per strand. Total number of pixels is 8X this!
// Here's a pinout that works with the Feather M4 (w/NeoPXL8 M4 FeatherWing):
int8_t pins[8] = { 13, 12, 11, 10, SCK, 5, 9, 6 };
// Alternates are available for the last 4 pins:
//int8_t pins[8] = { 13, 12, 11, 10, PIN_SERIAL1_RX, PIN_SERIAL1_TX, SCL, SDA };
Adafruit_NeoPXL8 neonLEDs(NUM_LED, pins, NEO_GRB);

// Onboard LEDs
Adafruit_NeoPixel onboardLEDs(4, 8, NEO_GRB + NEO_KHZ800);

// DOTSTARs
#include <Adafruit_DotStar.h>
#include <SPI.h>
#define NUMDOTSTARS 288 // Number of dotstars
#define DATAPIN    3
#define CLOCKPIN   2
Adafruit_DotStar dotstars(NUMDOTSTARS, DATAPIN, CLOCKPIN, DOTSTAR_BRG);
// Hardware SPI is a little faster, but must be wired to specific pins
// (Arduino Uno = pin 11 for data, 13 for clock, other boards are different).
//Adafruit_DotStar dotstars(NUMDOTSTARS, DOTSTAR_BRG);
uint32_t dotstarHueOffset = 0;

// NeoTrellis
Adafruit_NeoTrellis trellis;
uint8_t lastPressed = 2;
boolean isDown[16];
uint8_t brightness = 56;
TrellisCallback blink(keyEvent evt) {
  // Check is the pad pressed?
  if (evt.bit.EDGE == SEESAW_KEYPAD_EDGE_RISING) {
    trellis.pixels.setPixelColor(evt.bit.NUM, Wheel(map(evt.bit.NUM, 0, trellis.pixels.numPixels(), 0, 255))); // on rising

    if (evt.bit.NUM == 3) {
      if (brightness < 255) {
        brightness += 16;
        neonLEDs.setBrightness(brightness);
        drawConsole("Brightness " + String(brightness));
      }
    } else if (evt.bit.NUM == 7) {
      if (brightness > 16) {
        brightness -= 16;
        neonLEDs.setBrightness(brightness);
        drawConsole("Brightness " + String(brightness));
      }
    } else if (evt.bit.NUM == 15) {
    } else {
      drawConsole("Press " + String(evt.bit.NUM));
      lastPressed = evt.bit.NUM;
    }
    isDown[evt.bit.NUM] = true;
  } else if (evt.bit.EDGE == SEESAW_KEYPAD_EDGE_FALLING) {
    // or is the pad released?
    isDown[evt.bit.NUM] = false;
    trellis.pixels.setPixelColor(evt.bit.NUM, 0); //off falling
  }

  // Turn on/off the neopixels!
  trellis.pixels.show();

  return 0;
}

uint8_t sparkles_r[8 * NUM_LED];
uint8_t sparkles_g[8 * NUM_LED];
uint8_t sparkles_b[8 * NUM_LED];

void setup() {
  Serial.begin(9600);
  // while(!Serial);
  onboardLEDs.begin();
  onboardLEDs.setPixelColor(0, 70, 30, 0);
  onboardLEDs.setPixelColor(1, 70, 30, 0);
  onboardLEDs.setPixelColor(2, 70, 30, 0);
  onboardLEDs.setPixelColor(3, 70, 30, 0);
  onboardLEDs.setBrightness(64);
  onboardLEDs.show(); // Initialize all pixels to 'off'

  neonLEDs.begin();
  neonLEDs.setBrightness(brightness);

  dotstars.begin(); // Initialize pins for output
  dotstars.setBrightness(255);
  dotstars.show();  // Turn all LEDs off ASAP

  for (uint16_t i = 0; i < sizeof(sparkles_r); i++) {
    sparkles_r[i] = uint8_t(random(255));
    sparkles_g[i] = uint8_t(random(255));
    sparkles_b[i] = uint8_t(random(255));
  }

  if (!trellis.begin()) {
    Serial.println("Could not start trellis, check wiring?");
    while (1);
  } else {
    Serial.println("NeoPixel Trellis started");
  }

  //activate all keys and set callbacks
  for (int i = 0; i < NEO_TRELLIS_NUM_KEYS; i++) {
    trellis.activateKey(i, SEESAW_KEYPAD_EDGE_RISING);
    trellis.activateKey(i, SEESAW_KEYPAD_EDGE_FALLING);
    trellis.registerCallback(i, blink);
  }

  // SCREEN
  tft.init(240, 240);                // Initialize ST7789 screen
  pinMode(TFT_BACKLIGHT, OUTPUT);
  digitalWrite(TFT_BACKLIGHT, HIGH); // Backlight on

  Serial.println(F("Initialized"));

  uint16_t time = millis();
  tft.fillScreen(ST77XX_BLACK);
  time = millis() - time;

  Serial.println(time, DEC);

  // large block of text
  tft.fillScreen(ST77XX_BLACK);
  testdrawtext("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur adipiscing ante sed nibh tincidunt feugiat. Maecenas enim massa, fringilla sed malesuada et, malesuada sit amet turpis. Sed porttitor neque ut ante pretium vitae malesuada nunc bibendum. Nullam aliquet ultrices massa eu hendrerit. Ut sed nisi lorem. In vestibulum purus a tortor imperdiet posuere. ", ST77XX_WHITE);
  tft.fillScreen(ST77XX_BLACK);

  tft.setCursor(0, 0);
  tft.setTextColor(ST77XX_ORANGE_YEL, ST77XX_BLACK);
  tft.print("Temerity OS v1.0.4");

  tft.drawBitmap(0, 176, eyes, 240, 64, ST77XX_ORANGE_RED);

  // trellis animation to show we're on
  for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
    trellis.pixels.setPixelColor(i, TrellisWheel(map(i, 0, trellis.pixels.numPixels(), 0, 255)));
    trellis.pixels.show();
    delay(10);
  }
  for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
    trellis.pixels.setPixelColor(i, 0x000000);
    trellis.pixels.show();
    delay(10);
  }

  drawConsole("Temerity OS v1.0.1");
  drawConsole("System ready");
  char lv[] = {char(0xCC), char(0xCC)};
  drawConsole(lv);

  pinMode(13, OUTPUT);

  initAccelerometer();
} // End setup

uint16_t frame = 0;
uint16_t millis_last = 0;
uint16_t sine_offset = 0;
float sine_ms = 10000;
uint16_t cylon = 0;

uint32_t sine_r = 0;
float sine_r_ms = 12000;
uint32_t sine_g = 0;
float sine_g_ms = 9000;
uint32_t sine_b = 0;
float sine_b_ms = 23000;


#define DOTSTARSPARKS 100
uint8_t dotstarMaxVel = 120;
uint16_t dotstarSparksNext = 0;
uint16_t dotstarSparksHue[DOTSTARSPARKS];
uint16_t dotstarSparksPos[DOTSTARSPARKS];
uint8_t dotstarSparksVel[DOTSTARSPARKS];
float dotstarSparksAtk[DOTSTARSPARKS];
uint16_t dotstarSparksTTL[DOTSTARSPARKS];
uint8_t dotstarR[NUMDOTSTARS];
uint8_t dotstarG[NUMDOTSTARS];
uint8_t dotstarB[NUMDOTSTARS];

bool onlyDotstar = false;
uint8_t msSinceNeoPixelPush = 0;
void loop() {
  trellis.read();  // interrupt management does all the work! :)
  uint16_t ms_elapsed = millis() - millis_last;
  msSinceNeoPixelPush += ms_elapsed;
  tft.setCursor(160, 0);
  tft.setTextSize(1);
  tft.setTextColor(ST77XX_ORANGE, ST77XX_BLACK);
  tft.print("MS: ");
  tft.print(ms_elapsed);
  tft.print("       ");

  // DOTSTARs
  if (lastPressed == 0) {
    // RAINBOWS
    for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
      uint32_t rgbcolor = dotstars.ColorHSV(dotstarHueOffset + (i * 1000), 255, 16);
      dotstars.setPixelColor(i, rgbcolor);
      dotstarHueOffset += 10;

      uint32_t rgbcolorDisplay = dotstars.ColorHSV(dotstarHueOffset + (i * 1000), 255, 255);
      tft.drawPixel(0, i + 30, tft.color565(getRedValueFromColor(rgbcolorDisplay), getGreenValueFromColor(rgbcolorDisplay), getBlueValueFromColor(rgbcolorDisplay)));
    }
  } else if (lastPressed == 2) {
    // Sparkle Party!
    if (random(60) < ms_elapsed) {
      dotstarSparksHue[dotstarSparksNext] = random(65535);
      dotstarSparksPos[dotstarSparksNext] = random(65535);
      dotstarSparksVel[dotstarSparksNext] = random(dotstarMaxVel);
      dotstarSparksAtk[dotstarSparksNext] = 0.0;
      dotstarSparksTTL[dotstarSparksNext] = 1000 + random(3000);
      dotstarSparksNext++;
      if (dotstarSparksNext >= DOTSTARSPARKS) {
        dotstarSparksNext = 0;
      }
    }

    for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
      dotstarR[i] = 1;
      dotstarG[i] = 1;
      dotstarB[i] = 1;
    }

    for (uint16_t s = 0; s < DOTSTARSPARKS; s++) {
      if (dotstarSparksPos[s]) {
        float pos = ((dotstarSparksPos[s] / 65535.0) * NUMDOTSTARS);
        for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
          float distance = abs(pos - i);
          if (distance < 5) { // TODO: Variable sizes?
            float val = 16.0 * (5.0 - distance) / 5.0; // Distance from spark position
            val = val * dotstarSparksAtk[s]; // Fade-in (attack)
            if (dotstarSparksTTL[s] < 1000) {
              val = val * (dotstarSparksTTL[s] / 1000.0); // Fade-out (TTL)
            }
            uint32_t rgbcolor = dotstars.ColorHSV(dotstarSparksHue[s], 255, uint8_t(val));
            dotstarR[i] += getRedValueFromColor(rgbcolor);
            dotstarG[i] += getGreenValueFromColor(rgbcolor);
            dotstarB[i] += getBlueValueFromColor(rgbcolor);
          }
        }
        dotstarSparksPos[s] += (dotstarSparksVel[s] - (dotstarMaxVel / 2)) * ms_elapsed;
        if (dotstarSparksAtk[s] < 1) {
          dotstarSparksAtk[s] = min(dotstarSparksAtk[s] + (0.001 * ms_elapsed), 1);
        }
        if (dotstarSparksTTL[s] > 0) {
          dotstarSparksTTL[s] = max(dotstarSparksTTL[s] - ms_elapsed, 0);
        }
      }
    }
    for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
      dotstars.setPixelColor(i, dotstars.Color(dotstarR[i], dotstarG[i], dotstarB[i]));
    }
  }
  if (isDown[15]) {
    for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
      dotstars.setPixelColor(i, neonLEDs.Color(255, 255, 255));
    }
  }

  dotstars.show();

  if (!onlyDotstar ) {
  msSinceNeoPixelPush = 0;
  // ONBOARD and TRELLIS
  if (lastPressed == 0) {
    // RAINBOWS
    onboardLEDs.setPixelColor(0, Wheel(((millis() / 200) + 0) * 3.5));
    onboardLEDs.setPixelColor(1, Wheel(((millis() / 200) + 10) * 3.5));
    onboardLEDs.setPixelColor(2, Wheel(((millis() / 200) + 20) * 3.5));
    onboardLEDs.setPixelColor(3, Wheel(((millis() / 200) + 30) * 3.5));
    trellis.pixels.setBrightness(50);
    for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
      trellis.pixels.setPixelColor(i, Wheel(((millis() / 200.0) + i) * 3.5));
    }
  } else if (lastPressed == 1) {
    // Orange sine
    onboardLEDs.setPixelColor(0, neonLEDs.Color(255, 50 + (sin((sine_offset / sine_ms) + 10) * 100), 0));
    onboardLEDs.setPixelColor(1, neonLEDs.Color(255, 50 + (sin((sine_offset / sine_ms) + 20) * 100), 0));
    onboardLEDs.setPixelColor(2, neonLEDs.Color(255, 50 + (sin((sine_offset / sine_ms) + 30) * 100), 0));
    onboardLEDs.setPixelColor(3, neonLEDs.Color(255, 50 + (sin((sine_offset / sine_ms) + 40) * 100), 0));
    for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
      trellis.pixels.setPixelColor(i, 0, 0, 0);
    }
  } else if (lastPressed == 2) {
    // Sparkle Party!
    onboardLEDs.setPixelColor(0, neonLEDs.Color(sparkles_r[0], sparkles_g[0], sparkles_b[0]));
    onboardLEDs.setPixelColor(1, neonLEDs.Color(sparkles_r[1], sparkles_g[1], sparkles_b[1]));
    onboardLEDs.setPixelColor(2, neonLEDs.Color(sparkles_r[2], sparkles_g[2], sparkles_b[2]));
    onboardLEDs.setPixelColor(3, neonLEDs.Color(sparkles_r[3], sparkles_g[3], sparkles_b[3]));
    for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
       trellis.pixels.setPixelColor(i, neonLEDs.Color(sparkles_r[i+5], sparkles_g[i+5], sparkles_b[i+5]));
    }
  } else if (lastPressed == 4){
    // Pink sine
    onboardLEDs.setPixelColor(0, neonLEDs.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + 10) * 100)));
    onboardLEDs.setPixelColor(1, neonLEDs.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + 20) * 100)));
    onboardLEDs.setPixelColor(2, neonLEDs.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + 30) * 100)));
    onboardLEDs.setPixelColor(3, neonLEDs.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + 40) * 100)));
  } else if (lastPressed == 5) {
    // Blue Green sine
    onboardLEDs.setPixelColor(0, neonLEDs.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + 10) * 100)));
    onboardLEDs.setPixelColor(1, neonLEDs.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + 20) * 100)));
    onboardLEDs.setPixelColor(2, neonLEDs.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + 30) * 100)));
    onboardLEDs.setPixelColor(3, neonLEDs.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + 40) * 100)));
  } else if (lastPressed == 6) {
    // cylon
    onboardLEDs.setPixelColor(0, neonLEDs.Color(255, 0, 0));
    onboardLEDs.setPixelColor(1, neonLEDs.Color(255, 0, 0));
    onboardLEDs.setPixelColor(2, neonLEDs.Color(255, 0, 0));
    onboardLEDs.setPixelColor(3, neonLEDs.Color(255, 0, 0));
    for (uint16_t x = 0; x < 4; x++) {
      for (uint16_t y = 0; y < 4; y++) {
        uint16_t i = (y * 4) + x;
        if (i == cylon) {
          trellis.pixels.setPixelColor(i, neonLEDs.Color(255, 0, 0));
        } else {
          trellis.pixels.setPixelColor(i, neonLEDs.Color(0, 0, 0));
        }
      }
    }
  } else {
    // OFF by default
    for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
      onboardLEDs.setPixelColor(0, 70, 30, 0);
      onboardLEDs.setPixelColor(1, 70, 30, 0);
      onboardLEDs.setPixelColor(2, 70, 30, 0);
      onboardLEDs.setPixelColor(3, 70, 30, 0);
      trellis.pixels.setPixelColor(i, 0, 0, 0);
    }
  }
  onboardLEDs.show();
  trellis.pixels.show();


  // NEON
  for (uint8_t r = 0; r < 8; r++) { // For each strand...
    for (int p = 0; p < NUM_LED; p++) { // For each pixel of strand...
      uint8_t pn = r * NUM_LED + p;
      if (lastPressed == 0) {
        // RAINBOWS
        neonLEDs.setPixelColor(r * NUM_LED + p, Wheel(((millis() / 200) + pn) * 3.5));
      } else if (lastPressed == 1) {
        // Orange sine
        // neonLEDs.setPixelColor(r * NUM_LED + p, neonLEDs.Color(255, 110, 0));
        neonLEDs.setPixelColor(r * NUM_LED + p, neonLEDs.Color(255, 50 + (sin((sine_offset / sine_ms) + (pn / 2.0)) * 100), 0));
        sine_offset += ms_elapsed;
        if (sine_offset > TWO_PI * sine_ms) {
          sine_offset -= TWO_PI * sine_ms;
        }
      } else if (lastPressed == 2) {
        // Sparkle Party!
        if (random(1000) < ms_elapsed) {
          sparkles_r[pn] = uint8_t(random(255));
          sparkles_g[pn] = uint8_t(random(255));
          sparkles_b[pn] = uint8_t(random(255));
        }
        neonLEDs.setPixelColor(r * NUM_LED + p, neonLEDs.Color(sparkles_r[pn], sparkles_g[pn], sparkles_b[pn]));
      } else if (lastPressed == 4) {
        // Pink sine
        neonLEDs.setPixelColor(r * NUM_LED + p, neonLEDs.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + (pn)) * 100)));
        sine_offset += ms_elapsed;
        if (sine_offset > TWO_PI * sine_ms) {
          sine_offset -= TWO_PI * sine_ms;
        }

      } else if (lastPressed == 5) {
        // Blue Green sine
        neonLEDs.setPixelColor(r * NUM_LED + p, neonLEDs.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + (pn)) * 100)));
        sine_offset += ms_elapsed;
        if (sine_offset > TWO_PI * sine_ms) {
          sine_offset -= TWO_PI * sine_ms;
        }
      } else if (lastPressed == 6) {
        // cylon
        if (pn == cylon) {
          neonLEDs.setPixelColor(r * NUM_LED + p, neonLEDs.Color(255, 0, 0));
        } else {
          neonLEDs.setPixelColor(r * NUM_LED + p, neonLEDs.Color(0, 0, 0));
        }
      } else if (lastPressed == 8) {
        // RGB sine waves
        sine_r += ms_elapsed / 8.0;
        sine_g += ms_elapsed / 7.0;
        sine_b += ms_elapsed / 6.0;
        if (sine_r > TWO_PI * sine_r_ms) {
          sine_r -= TWO_PI * sine_r_ms;
        }
        if (sine_g > TWO_PI * sine_g_ms) {
          sine_g -= TWO_PI * sine_g_ms;
        }
        if (sine_b > TWO_PI * sine_b_ms) {
          sine_b -= TWO_PI * sine_b_ms;
        }
        neonLEDs.setPixelColor(r * NUM_LED + p, neonLEDs.Color(sin((sine_r / sine_r_ms) + (pn / 4.0)) * 255, sin((sine_g / sine_g_ms) + (pn / 3.0)) * 255, sin((sine_b / sine_b_ms) - (pn / 5.0)) * 255));
      } else {
        // RAINBOWS by default
        // neonLEDs.setPixelColor(r * NUM_LED + p, Wheel((frame/100  + p)*3));
        neonLEDs.setPixelColor(r * NUM_LED + p, Wheel(((millis() / 200) + pn) * 3.5));
      }
      if (isDown[15]) {
        neonLEDs.setPixelColor(r * NUM_LED + p, neonLEDs.Color(255, 255, 255));
      }
    }
  }
  neonLEDs.show();


  cylon += 1;
  if (cylon > NUM_LED * 8) {
    cylon = 0;
  }

  float fade = ms_elapsed / 4.0;
  for (uint16_t i = 0; i < sizeof(sparkles_r); i++) {
    if (sparkles_r[i] - fade > 0) {
      sparkles_r[i] -= fade;
    } else {
      sparkles_r[i] = 0;
    }
    if (sparkles_g[i] - fade > 0) {
      sparkles_g[i] -= fade;
    } else {
      sparkles_g[i] = 0;
    }
    if (sparkles_b[i] - fade > 0) {
      sparkles_b[i] -= fade;
    } else {
      sparkles_b[i] = 0;
    }
  }

  }

  displayAccelerometer();

  frame++;
  if (frame > 65535) {
    frame = 0;
  }

  millis_last = millis();

  delay(16); // the trellis has a resolution of around 60hz
}


uint32_t Wheel(byte WheelPos)
{
  WheelPos = 255 - (WheelPos % 255);
  if (WheelPos < 85)
  {
    return neonLEDs.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  }
  else if (WheelPos < 170)
  {
    WheelPos -= 85;
    return neonLEDs.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  }
  else
  {
    WheelPos -= 170;
    return neonLEDs.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
  }
}

void testdrawtext(char *text, uint16_t color) {
  tft.setCursor(0, 0);
  tft.setTextColor(color);
  tft.setTextWrap(true);
  tft.print(text);
}


/******************************************/

// Input a value 0 to 255 to get a color value.
// The colors are a transition r - g - b - back to r.
uint32_t TrellisWheel(byte WheelPos) {
  if (WheelPos < 85) {
    return trellis.pixels.Color(WheelPos * 3, 55 - WheelPos * 3, 0);
  } else if (WheelPos < 170) {
    WheelPos -= 85;
    return trellis.pixels.Color(55 - WheelPos * 3, 0, WheelPos * 3);
  } else {
    WheelPos -= 170;
    return trellis.pixels.Color(0, WheelPos * 3, 55 - WheelPos * 3);
  }
  return 0;
}

// Accelerometer
#include <Wire.h>
#include <Adafruit_MSA301.h>
#include <Adafruit_Sensor.h>
Adafruit_MSA301 msa;

void initAccelerometer() {
 // Try to initialize MSA301
  if (! msa.begin()) {
    Serial.println("Failed to find MSA301 chip");
    while (1) {
      delay(10);
    }
  }
  Serial.println("MSA301 Found!");
  //msa.setDataRate(MSA301_DATARATE_31_25_HZ);
  Serial.print("Data rate set to: ");
  switch (msa.getDataRate()) {
    case MSA301_DATARATE_1_HZ: Serial.println("1 Hz"); break;
    case MSA301_DATARATE_1_95_HZ: Serial.println("1.95 Hz"); break;
    case MSA301_DATARATE_3_9_HZ: Serial.println("3.9 Hz"); break;
    case MSA301_DATARATE_7_81_HZ: Serial.println("7.81 Hz"); break;
    case MSA301_DATARATE_15_63_HZ: Serial.println("15.63 Hz"); break;
    case MSA301_DATARATE_31_25_HZ: Serial.println("31.25 Hz"); break;
    case MSA301_DATARATE_62_5_HZ: Serial.println("62.5 Hz"); break;
    case MSA301_DATARATE_125_HZ: Serial.println("125 Hz"); break;
    case MSA301_DATARATE_250_HZ: Serial.println("250 Hz"); break;
    case MSA301_DATARATE_500_HZ: Serial.println("500 Hz"); break;
    case MSA301_DATARATE_1000_HZ: Serial.println("1000 Hz"); break;
  }

  //msa.setPowerMode(MSA301_SUSPENDMODE);
  Serial.print("Power mode set to: ");
  switch (msa.getPowerMode()) {
    case MSA301_NORMALMODE: Serial.println("Normal"); break;
    case MSA301_LOWPOWERMODE: Serial.println("Low Power"); break;
    case MSA301_SUSPENDMODE: Serial.println("Suspend"); break;
  }

  //msa.setBandwidth(MSA301_BANDWIDTH_31_25_HZ);
  Serial.print("Bandwidth set to: ");
  switch (msa.getBandwidth()) {
    case MSA301_BANDWIDTH_1_95_HZ: Serial.println("1.95 Hz"); break;
    case MSA301_BANDWIDTH_3_9_HZ: Serial.println("3.9 Hz"); break;
    case MSA301_BANDWIDTH_7_81_HZ: Serial.println("7.81 Hz"); break;
    case MSA301_BANDWIDTH_15_63_HZ: Serial.println("15.63 Hz"); break;
    case MSA301_BANDWIDTH_31_25_HZ: Serial.println("31.25 Hz"); break;
    case MSA301_BANDWIDTH_62_5_HZ: Serial.println("62.5 Hz"); break;
    case MSA301_BANDWIDTH_125_HZ: Serial.println("125 Hz"); break;
    case MSA301_BANDWIDTH_250_HZ: Serial.println("250 Hz"); break;
    case MSA301_BANDWIDTH_500_HZ: Serial.println("500 Hz"); break;
  }

  //msa.setRange(MSA301_RANGE_2_G);
  Serial.print("Range set to: ");
  switch (msa.getRange()) {
    case MSA301_RANGE_2_G: Serial.println("+-2G"); break;
    case MSA301_RANGE_4_G: Serial.println("+-4G"); break;
    case MSA301_RANGE_8_G: Serial.println("+-8G"); break;
    case MSA301_RANGE_16_G: Serial.println("+-16G"); break;
  }

  //msa.setResolution(MSA301_RESOLUTION_14 );
  Serial.print("Resolution set to: ");
  switch (msa.getResolution()) {
    case MSA301_RESOLUTION_14: Serial.println("14 bits"); break;
    case MSA301_RESOLUTION_12: Serial.println("12 bits"); break;
    case MSA301_RESOLUTION_10: Serial.println("10 bits"); break;
    case MSA301_RESOLUTION_8: Serial.println("8 bits"); break;
  }
}

int8_t accelerationXMax = 0;
int8_t accelerationXMin = 0;
int8_t accelerationYMax = 0;
int8_t accelerationYMin = 0;
int8_t accelerationZMax = 0;
int8_t accelerationZMin = 0;
void displayAccelerometer() {
  /* Display the results (acceleration is measured in m/s^2) */
  sensors_event_t event;
  msa.getEvent(&event);
  accelerationXMax = max(accelerationXMax, event.acceleration.x);
  accelerationXMin = min(accelerationXMin, event.acceleration.x);
  accelerationYMax = max(accelerationYMax, event.acceleration.y);
  accelerationYMin = min(accelerationYMin, event.acceleration.y);
  accelerationZMax = max(accelerationZMax, event.acceleration.z);
  accelerationZMin = min(accelerationZMin, event.acceleration.z);

  tft.setTextSize(2);
  tft.setCursor(0, 10);
  tft.setTextColor(ST77XX_ORANGE_DK, ST77XX_BLACK);
  tft.print("x");
  tft.setTextColor(ST77XX_ORANGE_RED, ST77XX_BLACK);
  tft.print(event.acceleration.x);

  tft.setCursor(80, 10);
  tft.setTextColor(ST77XX_ORANGE_DK, ST77XX_BLACK);
  tft.print("y");
  tft.setTextColor(ST77XX_ORANGE_RED, ST77XX_BLACK);
  tft.print(event.acceleration.y);

  tft.setCursor(160, 10);
  tft.setTextColor(ST77XX_ORANGE_DK, ST77XX_BLACK);
  tft.print("z");
  tft.setTextColor(ST77XX_ORANGE_RED, ST77XX_BLACK);
  tft.print(event.acceleration.z);

  // Show min/max acceleration
  tft.setTextSize(1);
  tft.setTextColor(ST77XX_ORANGE_DK, ST77XX_BLACK);
  tft.setCursor(0, 29);
  tft.print(accelerationXMin);
  tft.print(" | ");
  tft.print(accelerationXMax);

  tft.setCursor(80, 29);
  tft.print(accelerationYMin);
  tft.print(" | ");
  tft.print(accelerationYMax);

  tft.setCursor(160, 29);
  tft.print(accelerationZMin);
  tft.print(" | ");
  tft.print(accelerationZMax);
}


// Ring buffer for console output
uint8_t consoleLines = 8;
String consoleBuffer[8];
uint8_t consolePointer = 0;
void drawConsole(String string) {
  Serial.println(string);
  consoleBuffer[consolePointer] = string;
  consolePointer = (consolePointer + 1) % 8;
  tft.setCursor(0, 90);
  tft.setTextSize(1);
  tft.setTextWrap(false);
  tft.setTextColor(ST77XX_ORANGE, ST77XX_BLACK);
  for (uint16_t i = 0; i < 8; i++) {
    tft.println(consoleBuffer[(i + consolePointer) % 8] + "                    "); // Dumb right pad
  }
}


uint8_t getRedValueFromColor(uint32_t c) {
  return c >> 16;
}
uint8_t getGreenValueFromColor(uint32_t c) {
    return c >> 8;
}
uint8_t getBlueValueFromColor(uint32_t c) {
    return c;
}