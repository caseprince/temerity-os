
const unsigned char eyes []PROGMEM = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x7f, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xc0,
  0x1, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xf0,
  0x3, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xfc,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xfc,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0,
  0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0,
  0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0,
  0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0,
  0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0,
  0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0
};

enum turnSignalStates {
  OFF, 
  LEFT,
  STARBOARD
};
turnSignalStates turnSignalState = OFF;

enum shieldModes {
  ROTATING_RAINBOW,
  ORANGE_SIN,
  SPARKLE_PARTY,
  PURPLE_PINK,
  BLUE_GREEN,
  CYLON,
  AUDIT,
  COORD_TEST,
  BORING_MODE,
  NONE
};
shieldModes shieldMode = ROTATING_RAINBOW;


#define MAX16BIT 65535

// DOTSTARs
#include <Adafruit_DotStar.h>
#include <SPI.h>
#define NUMDOTSTARS 288 // Number of dotstars
#define DATAPIN    3
#define CLOCKPIN   2
Adafruit_DotStar dotstars(NUMDOTSTARS, DATAPIN, CLOCKPIN, DOTSTAR_BRG);
// Hardware SPI is a little faster, but must be wired to specific pins
// (Arduino Uno = pin 11 for data, 13 for clock, other boards are different).
//Adafruit_DotStar dotstars(NUMDOTSTARS, DOTSTAR_BRG);
uint32_t dotstarHueOffset = 0;

// Onboard Screen
#include <Adafruit_GFX.h>    // Core graphics library
#include <Adafruit_ST7789.h> // Hardware-specific library for ST7789
#include <SPI.h>
#define TFT_CS        44 // PyBadge/PyGamer display control pins: chip select
#define TFT_RST       46 // Display reset
#define TFT_DC        45 // Display data/command select
#define TFT_BACKLIGHT 47 // Display backlight pin
Adafruit_ST7789 tft = Adafruit_ST7789(&SPI1, TFT_CS, TFT_DC, TFT_RST);
// Custom colors
#define ST77XX_ORANGE_YEL 0xFDC0
#define ST77XX_ORANGE_RED 0xFB80
#define ST77XX_ORANGE_DK 0xA240

// NeoPXL8 8 x 20
#include <Adafruit_NeoPXL8.h>
#define NUM_LED 20  // Per strand. Total number of pixels is 8X this!
#define NUM_NEON 160
// Here's a pinout that works with the Feather M4 (w/NeoPXL8 M4 FeatherWing):
int8_t pins[8] = { SCK, 5, 9, 6, 13, 12, 11, 10 };
// Alternates are available for the last 4 pins:
// int8_t pins[8] = { 13, 12, 11, 10, PIN_SERIAL1_RX, PIN_SERIAL1_TX, SCL, SDA };
Adafruit_NeoPXL8 neonLEDs(NUM_LED, pins, NEO_GRB);

// Onboard LEDs
Adafruit_NeoPixel onboardLEDs(4, 8, NEO_GRB + NEO_KHZ800);

// NeoTrellis
#include "Adafruit_NeoTrellis.h"
Adafruit_NeoTrellis trellis;
boolean isDown[16];
uint8_t brightness = 127;
TrellisCallback blink(keyEvent evt) {
  // Check is the pad pressed?
  if (evt.bit.EDGE == SEESAW_KEYPAD_EDGE_RISING) {
    trellis.pixels.setPixelColor(evt.bit.NUM, Wheel(map(evt.bit.NUM, 0, trellis.pixels.numPixels(), 0, 255))); // on rising
    
    if (evt.bit.NUM == 3) {
      if (brightness < 255) {
        brightness += 32;
        neonLEDs.setBrightness(brightness);
        drawConsole("Brightness " + String(brightness));
      }
    } else if (evt.bit.NUM == 7) {
      if (brightness > 16) {
        brightness -= 32;
        neonLEDs.setBrightness(brightness);
        drawConsole("Brightness " + String(brightness));
      }
    } else if (evt.bit.NUM == 12 || evt.bit.NUM == 13 || evt.bit.NUM == 15) {
      // Do nothing here for momentary buttons
    } else {
      drawConsole("Press " + String(evt.bit.NUM));
      if (evt.bit.NUM == 0) {
        shieldMode = ROTATING_RAINBOW;
      } else if (evt.bit.NUM == 1) {
        shieldMode = ORANGE_SIN;
      } else if (evt.bit.NUM == 2) {
        shieldMode = SPARKLE_PARTY;
      } else if (evt.bit.NUM == 4) {
        shieldMode = PURPLE_PINK;
      } else if (evt.bit.NUM == 5) {
        shieldMode = BLUE_GREEN;
      } else if (evt.bit.NUM == 6) {
        shieldMode = CYLON;
      } else if (evt.bit.NUM == 8) {
        shieldMode = AUDIT;
      } else if (evt.bit.NUM == 9) {
        shieldMode = COORD_TEST;
      } else if (evt.bit.NUM == 11) {
        shieldMode = BORING_MODE;
      }
    }

    if (evt.bit.NUM == 12) {
      if (turnSignalState != LEFT) {
        turnSignalState = LEFT;
      } else {
        turnSignalState = OFF;
      }
    } else if (evt.bit.NUM == 13) {
      if (turnSignalState != STARBOARD) {
        turnSignalState = STARBOARD;
      } else {
        turnSignalState = OFF;
      }
    } else {
      turnSignalState = OFF;
    }
    isDown[evt.bit.NUM] = true;
  } else if (evt.bit.EDGE == SEESAW_KEYPAD_EDGE_FALLING) {
    // or is the pad released?
    isDown[evt.bit.NUM] = false;
    trellis.pixels.setPixelColor(evt.bit.NUM, 0); //off falling
  }

  // Turn on/off the neopixels!
  trellis.pixels.show();

  return 0;
}

/************* COORDS **************/
// All measurements are in mm
const float DEG2RAD = PI / 180.0f;
const float RAD2DEG = 180.0f / PI;
const float FORK_ANGLE = -120.0 * DEG2RAD;
const float FORK_Z_OFFSET = 72;
const float TOP_ANGLE = -8.0 * DEG2RAD;
const float BOTTOM_ANGLE = -30.0 * DEG2RAD;
const float HELM_ANGLEZ = 60 * DEG2RAD;
const float HELM_ANGLEX = 75 * DEG2RAD;

const float NEON_DIST = 49.0;
float neonLEDs_x[8 * NUM_LED];
float neonLEDs_y[8 * NUM_LED];
float neonLEDs_z[8 * NUM_LED];
float neonLEDs_xMin = 0.0;
float neonLEDs_yMin = 0.0;
float neonLEDs_zMin = 0.0;
float neonLEDs_xMax = 0.0;
float neonLEDs_yMax = 0.0;
float neonLEDs_zMax = 0.0;

const float DOTSTAR_DIST = 6.95;
float dotstarLEDs_x[NUMDOTSTARS];
float dotstarLEDs_y[NUMDOTSTARS];
float dotstarLEDs_z[NUMDOTSTARS];
float dotstarLEDs_xMin = 0.0;
float dotstarLEDs_yMin = 0.0;
float dotstarLEDs_zMin = 0.0;
float dotstarLEDs_xMax = 0.0;
float dotstarLEDs_yMax = 0.0;
float dotstarLEDs_zMax = 0.0;

float coordTest_x = 0.0;
float coordTest_y = 0.0;
float coordTest_z = 0.0;

uint8_t sparkles_r[8 * NUM_LED];
uint8_t sparkles_g[8 * NUM_LED];
uint8_t sparkles_b[8 * NUM_LED];

/************* SETUP **************/

void setup() {
  Serial.begin(9600);
  // while(!Serial);
  onboardLEDs.begin();
  onboardLEDs.setPixelColor(0, 70, 30, 0);
  onboardLEDs.setPixelColor(1, 70, 30, 0);
  onboardLEDs.setPixelColor(2, 70, 30, 0);
  onboardLEDs.setPixelColor(3, 70, 30, 0);
  onboardLEDs.setBrightness(64);
  onboardLEDs.show(); // Initialize all pixels to 'off'

  neonLEDs.begin();
  neonLEDs.setBrightness(brightness);

  dotstars.begin(); // Initialize pins for output
  dotstars.setBrightness(255);
  dotstars.show();  // Turn all LEDs off ASAP

  for (uint16_t i = 0; i < sizeof(sparkles_r); i++) {
    sparkles_r[i] = uint8_t(random(255));
    sparkles_g[i] = uint8_t(random(255));
    sparkles_b[i] = uint8_t(random(255));
  }

  if (!trellis.begin()) {
    Serial.println("Could not start trellis, check wiring?");
    while (1);
  } else {
    Serial.println("NeoPixel Trellis started");
  }

  //activate all keys and set callbacks
  for (int i = 0; i < NEO_TRELLIS_NUM_KEYS; i++) {
    trellis.activateKey(i, SEESAW_KEYPAD_EDGE_RISING);
    trellis.activateKey(i, SEESAW_KEYPAD_EDGE_FALLING);
    trellis.registerCallback(i, blink);
  }

  // SCREEN
  tft.init(240, 240);                // Initialize ST7789 screen
  pinMode(TFT_BACKLIGHT, OUTPUT);
  digitalWrite(TFT_BACKLIGHT, HIGH); // Backlight on

  Serial.println(F("Initialized"));

  uint16_t time = millis();
  tft.fillScreen(ST77XX_BLACK);
  time = millis() - time;

  Serial.println(time, DEC);

  // large block of text
  tft.fillScreen(ST77XX_BLACK);
  testdrawtext("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur adipiscing ante sed nibh tincidunt feugiat. Maecenas enim massa, fringilla sed malesuada et, malesuada sit amet turpis. Sed porttitor neque ut ante pretium vitae malesuada nunc bibendum. Nullam aliquet ultrices massa eu hendrerit. Ut sed nisi lorem. In vestibulum purus a tortor imperdiet posuere. ", ST77XX_WHITE);
  tft.fillScreen(ST77XX_BLACK);

  tft.setCursor(0, 0);
  tft.setTextColor(ST77XX_ORANGE_YEL, ST77XX_BLACK);
  tft.print("Temerity OS v1.0.4");

  tft.drawBitmap(0, 176, eyes, 240, 64, ST77XX_ORANGE_RED);

  // trellis animation to show we're on
  for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
    trellis.pixels.setPixelColor(i, TrellisWheel(map(i, 0, trellis.pixels.numPixels(), 0, 255)));
    trellis.pixels.show();
    delay(10);
  }
  for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
    trellis.pixels.setPixelColor(i, 0x000000);
    trellis.pixels.show();
    delay(10);
  }

  drawConsole("Temerity OS v1.0.1");
  drawConsole("System ready");
  char lv[] = {char(0xCC), char(0xCC)};
  drawConsole(lv);

  pinMode(13, OUTPUT);

  initAccelerometer();

  /********** COORDS **********/
  for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
    uint16_t p = i;
    if (i < 144) {
      dotstarLEDs_z[i] = 60.0;
    } else {
      p -= 144;
      dotstarLEDs_z[i] = -60.0;
    }
    dotstarLEDs_x[i] = cos(FORK_ANGLE) * (p * DOTSTAR_DIST);
    dotstarLEDs_y[i] = 50.0 + sin(FORK_ANGLE) * (p * DOTSTAR_DIST);
    dotstarLEDs_xMin = min(dotstarLEDs_x[i], dotstarLEDs_xMin);
    dotstarLEDs_yMin = min(dotstarLEDs_y[i], dotstarLEDs_yMin);
    dotstarLEDs_xMax = max(dotstarLEDs_x[i], dotstarLEDs_xMax);
    dotstarLEDs_yMax = max(dotstarLEDs_y[i], dotstarLEDs_yMax);
  }

  for (uint8_t r = 0; r < 8; r++) { // For each strand...
    for (int p = 0; p < NUM_LED; p++) { // For each pixel of strand...
      uint8_t pn = r * NUM_LED + p;
      neonLEDs_x[pn] = 0.0;
      neonLEDs_y[pn] = 0.0;
      neonLEDs_z[pn] = 0.0;
      float helmYOffset = 10.0;
      if (r == 7) { // HELM - all Xs = 0.0 for now...
        if (p < 6) { // \.
          neonLEDs_z[pn] = -NEON_DIST + cos(HELM_ANGLEZ) * ((5 - p) * -NEON_DIST);
          neonLEDs_y[pn] = helmYOffset + sin(HELM_ANGLEZ) * ((5 - p) * NEON_DIST);
          neonLEDs_x[pn] = 20.0 + cos(HELM_ANGLEX) * ((5 - p) * NEON_DIST);
        } else if (p == 6) { // _
          neonLEDs_z[pn] = 0.0;
          neonLEDs_y[pn] = helmYOffset;
        } else if (p <= 12) { // /
          neonLEDs_z[pn] = NEON_DIST + cos(HELM_ANGLEZ) * ((p - 7) * NEON_DIST);
          neonLEDs_y[pn] = helmYOffset + sin(HELM_ANGLEZ) * ((p - 7) * NEON_DIST);
          neonLEDs_x[pn] = 20.0 + cos(HELM_ANGLEX) * ((p - 7) * NEON_DIST);
        }
      } else if (r == 3 || r == 5) { // FORKS
        neonLEDs_x[pn] = cos(FORK_ANGLE) * (p * NEON_DIST);
        neonLEDs_y[pn] = sin(FORK_ANGLE) * (p * NEON_DIST);
        neonLEDs_z[pn] = -FORK_Z_OFFSET;
        if (r == 5) {
          neonLEDs_z[pn] = FORK_Z_OFFSET;
        }
      } else if (r == 6) { //-- TOP TUBE
        if (p <= 9) {
          neonLEDs_x[pn] = 80.0 + cos(TOP_ANGLE) * (p * NEON_DIST);
          neonLEDs_y[pn] = -150.0 + sin(TOP_ANGLE) * (p * NEON_DIST);
        } else {
          neonLEDs_x[pn] = 80.0 + cos(TOP_ANGLE) * (10 * NEON_DIST) + cos(FORK_ANGLE) * ((p - 10) * NEON_DIST);
          neonLEDs_y[pn] = -150.0 + sin(TOP_ANGLE) * (10 * NEON_DIST) + sin(FORK_ANGLE) * ((p - 10) * NEON_DIST);
        }
      } else if (r == 2 || r == 0) { //__ BOTTOM TUBE / CHAIN STAYS
        neonLEDs_x[pn] = 50.0 + cos(BOTTOM_ANGLE) * (p * NEON_DIST);
        neonLEDs_y[pn] = -210.0 + sin(BOTTOM_ANGLE) * (p * NEON_DIST);
        if (p <= 9 ) {
          neonLEDs_z[pn] = 23.0;         
        } else if (p <= 18 ) {
          neonLEDs_z[pn] = 23.0 + (p - 9)/7.0 * 50.0; // I actually have an aunt named Sally
        } else {
          neonLEDs_z[pn] = 23.0 + 50.0 - (p - 18)/2.0 * 28.0;
        }
        if (r == 2) { 
           neonLEDs_z[pn] = -neonLEDs_z[pn]; // Port is mirror of starboard!
        }
      } else if (r == 1) { // n BRAKE
        if (p <= 7) { // PORT
          neonLEDs_x[pn] = 838.0 + cos(FORK_ANGLE) * (p * -NEON_DIST);
          neonLEDs_y[pn] = -610.0 + sin(FORK_ANGLE) * (p * -NEON_DIST);
          neonLEDs_z[pn] = -58.0;
          if (p == 7) {
            neonLEDs_z[pn] = -40.0;
          }
        } else if (p == 8) { // TOP MIDDLE
          neonLEDs_x[pn] = 838.0 + cos(FORK_ANGLE) * (7 * -NEON_DIST);
          neonLEDs_y[pn] = -610.0 + sin(FORK_ANGLE) * (7 * -NEON_DIST);
          neonLEDs_z[pn] = 0.0;
        } else if (p <= 16) { // STARBOARD
          neonLEDs_x[pn] = 838.0 + cos(FORK_ANGLE) * ((16 - p) * -NEON_DIST);
          neonLEDs_y[pn] = -610.0 + sin(FORK_ANGLE) * ((16 - p) * -NEON_DIST);
          neonLEDs_z[pn] = 58.0;
          if (p == 9) {
            neonLEDs_z[pn] = 40.0;
          }      
        }
      }
      neonLEDs_xMin = min(neonLEDs_x[pn], neonLEDs_xMin);
      neonLEDs_yMin = min(neonLEDs_y[pn], neonLEDs_yMin);
      neonLEDs_zMin = min(neonLEDs_z[pn], neonLEDs_zMin);
      neonLEDs_xMax = max(neonLEDs_x[pn], neonLEDs_xMax);
      neonLEDs_yMax = max(neonLEDs_y[pn], neonLEDs_yMax);
      neonLEDs_zMax = max(neonLEDs_z[pn], neonLEDs_zMax);
    }
  }

  // Z makes more sense as symetrical, so no need to shift origin:
  float BBoxPadding = 200;
  dotstarLEDs_xMax -= dotstarLEDs_xMin - BBoxPadding * 2.0;
  dotstarLEDs_yMax -= dotstarLEDs_yMin - BBoxPadding * 2.0;
   for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
    dotstarLEDs_x[i] -= dotstarLEDs_xMin - BBoxPadding;
    dotstarLEDs_y[i] -= dotstarLEDs_yMin - BBoxPadding;
  }
  neonLEDs_xMax -= neonLEDs_xMin - BBoxPadding * 2.0;
  neonLEDs_yMax -= neonLEDs_yMin - BBoxPadding * 2.0;
  for (int pn = 0; pn < 8 * NUM_LED; pn++) {
    neonLEDs_x[pn] -= neonLEDs_xMin - BBoxPadding;
    neonLEDs_y[pn] -= neonLEDs_yMin - BBoxPadding;
  }

} // End setup

uint16_t millis_last = 0;
uint16_t sine_offset = 0;
float sine_ms = 10000;
uint16_t cylon = 0;

uint32_t sine_r = 0;
float sine_r_ms = 12000;
uint32_t sine_g = 0;
float sine_g_ms = 9000;
uint32_t sine_b = 0;
float sine_b_ms = 23000;


#define DOTSTARSPARKS 100
// uint8_t dotstarMaxVel = 12.0;
uint16_t dotstarSparksNext = 0;
uint16_t dotstarSparksHue[DOTSTARSPARKS];
float dotstarSparksAtk[DOTSTARSPARKS];
uint16_t dotstarSparksTTL[DOTSTARSPARKS];
uint16_t dotstarSparksPos[DOTSTARSPARKS];
float dotstarSparksVel[DOTSTARSPARKS];
float dotstarSparksAcc[DOTSTARSPARKS];

uint8_t dotstarR[NUMDOTSTARS];
uint8_t dotstarG[NUMDOTSTARS];
uint8_t dotstarB[NUMDOTSTARS];

bool onlyDotstar = false;
uint8_t msSinceNeoPixelPush = 0; // Currently unused
uint16_t ms_elapsed = 0;
shieldModes shieldModeWas = NONE;

/************* LOOP **************/
void loop() {


  ms_elapsed = millis() - millis_last;
  msSinceNeoPixelPush += ms_elapsed;
  tft.setCursor(160, 0);
  tft.setTextSize(1);
  tft.setTextColor(ST77XX_ORANGE, ST77XX_BLACK);
  tft.print("MS: ");
  tft.print(ms_elapsed);
  tft.print("       ");

  trellis.read();  // interrupt management does all the work! :)
  if (shieldMode == ROTATING_RAINBOW) {
    // Boring Horizontal rainbow:
    // double hueDist = dist(0, 0, neonLEDs_x[pn], neonLEDs_y[pn], 10.0, -20.0);

    // ROTATING RAINBOW!:
    for (uint8_t i = 0; i < NUM_NEON; i++) {
      double hueRotX = cos(millis() * 0.001);
      double hueRotY = sin(millis() * 0.001);
      double pt1[2] = {0, 0};
      double pt2[2] = {hueRotX, hueRotY};
      double pt3[2];
      pt3[0] = neonLEDs_x[i] - neonLEDs_xMax/2; // Offset LED pt to center rainbow rotation
      pt3[1] = neonLEDs_y[i] - neonLEDs_yMax/2;
      double hueDist = LineToPointDistance2D(pt1, pt2, pt3, false);
      uint16_t hue = (hueDist * -50) + (millis() * 10);
      neonLEDs.setPixelColor(i, neonLEDs.ColorHSV(hue, 255, 255));
    }

    // Boring but dense rainbow:
    for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
      uint16_t hue = dotstarHueOffset + (i * 1000);
      if (i >= 144) {
        hue += 20 * 1000;
      }
      uint32_t rgbcolor = dotstars.ColorHSV(hue, 255, 16);
      dotstars.setPixelColor(i, rgbcolor);
      dotstarHueOffset += 10;

      uint32_t rgbcolorDisplay = dotstars.ColorHSV(hue, 255, 255);
      tft.drawPixel(0, i + 30, tft.color565(getRedValueFromColor(rgbcolorDisplay), getGreenValueFromColor(rgbcolorDisplay), getBlueValueFromColor(rgbcolorDisplay)));
    }

    onboardLEDs.setPixelColor(0, Wheel(((millis() / 200) + 0) * 3.5));
    onboardLEDs.setPixelColor(1, Wheel(((millis() / 200) + 10) * 3.5));
    onboardLEDs.setPixelColor(2, Wheel(((millis() / 200) + 20) * 3.5));
    onboardLEDs.setPixelColor(3, Wheel(((millis() / 200) + 30) * 3.5));
    trellis.pixels.setBrightness(50);
    for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
      trellis.pixels.setPixelColor(i, Wheel(((millis() / 200.0) + i) * 3.5));
    }
  } else if (shieldMode == ORANGE_SIN) {
    // neonLEDs.setPixelColor(r * NUM_LED + p, neonLEDs.Color(255, 110, 0));
    for (uint8_t i = 0; i < NUM_NEON; i++) {
      neonLEDs.setPixelColor(i, neonLEDs.Color(255, 50 + (sin((sine_offset / sine_ms) + (i / 2.0)) * 100), 0));
    }
    for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
      //dotstars.setPixelColor(i, dotstars.Color(1, 5, 0)); //50 + (sin((sine_offset / sine_ms) + (i / 2.0)) * 100), 0));
      dotstars.setPixelColor(i, dotstars.ColorHSV(20000 + (sin((sine_offset / sine_ms) + (i / 6.0))) * 1300, 255, 16));
      sine_offset += ms_elapsed;
    }
     // Orange sine
    onboardLEDs.setPixelColor(0, neonLEDs.Color(255, 50 + (sin((sine_offset / sine_ms) + 10) * 100), 0));
    onboardLEDs.setPixelColor(1, neonLEDs.Color(255, 50 + (sin((sine_offset / sine_ms) + 11) * 100), 0));
    onboardLEDs.setPixelColor(2, neonLEDs.Color(255, 50 + (sin((sine_offset / sine_ms) + 12) * 100), 0));
    onboardLEDs.setPixelColor(3, neonLEDs.Color(255, 50 + (sin((sine_offset / sine_ms) + 13) * 100), 0));
    for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
      trellis.pixels.setPixelColor(i, 0, 0, 0);
    }
    sine_offset += ms_elapsed;
    if (sine_offset > TWO_PI * sine_ms) {
      sine_offset -= TWO_PI * sine_ms;
    }
  } else if (shieldMode == SPARKLE_PARTY) {
    for (uint8_t i = 0; i < NUM_NEON; i++) {
      if (random(1000) < ms_elapsed) {
        sparkles_r[i] = uint8_t(random(255));
        sparkles_g[i] = uint8_t(random(255));
        sparkles_b[i] = uint8_t(random(255));
      }
      neonLEDs.setPixelColor(i, neonLEDs.Color(sparkles_r[i], sparkles_g[i], sparkles_b[i]));
    }
    dotstarSparkleParty();
    onboardLEDs.setPixelColor(0, neonLEDs.Color(sparkles_r[0], sparkles_g[0], sparkles_b[0]));
    onboardLEDs.setPixelColor(1, neonLEDs.Color(sparkles_r[1], sparkles_g[1], sparkles_b[1]));
    onboardLEDs.setPixelColor(2, neonLEDs.Color(sparkles_r[2], sparkles_g[2], sparkles_b[2]));
    onboardLEDs.setPixelColor(3, neonLEDs.Color(sparkles_r[3], sparkles_g[3], sparkles_b[3]));
    for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
       trellis.pixels.setPixelColor(i, neonLEDs.Color(sparkles_r[i+5], sparkles_g[i+5], sparkles_b[i+5]));
    }
  } else if (shieldMode == PURPLE_PINK) {
    for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
      double pt1[2] = {dotstarLEDs_z[i], dotstarLEDs_y[i]};
      double pt2[2] = {sin(millis() / 1600.0) * 300.0, sin(millis() / 2000.0) * -300.0 + 650.0}; // - neonLEDs_yMax / 2.0;
      // double pt3[2] = {sin(millis() / 2100.0) * -300.0, sin(millis() / 2800.0) * 300.0 + 650.0}; // - neonLEDs_yMax / 2.0;
      double dist = Distance(pt1, pt2); // + Distance(pt1, pt3);
      double sinRatio = (sin(dist/10.0) + 1.0) / 2.0;
      float brightnessRatio = easeInCirc(easeInCirc(sinRatio));
      if (dist < 13) {
        dotstars.setPixelColor(i, dotstars.ColorHSV(43000, 255, 45));
      } else {
        uint32_t hue = 33000 + (1.0 - easeInCirc(sinRatio)) * 7000; // + (dotstarLEDs_y[i] * -5.0);
        if (brightnessRatio > 0.90) { // 0.90 is very sparkly!
          dotstars.setPixelColor(i, dotstars.ColorHSV(hue, 120, 195));
        } else {
          dotstars.setPixelColor(i, dotstars.ColorHSV(hue, 240, brightnessRatio * 45.0));
        }        
      }      
    }
    // Pink & Purple Gradient
    // if (shieldModeWas != 4) {
      for (uint8_t i = 0; i < NUM_NEON; i++) {
        neonLEDs.setPixelColor(i, neonLEDs.ColorHSV(45000 + neonLEDs_y[i] / neonLEDs_yMax * 21000, 255, 255));
      }    
      onboardLEDs.setPixelColor(0, neonLEDs.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + 10) * 100)));
      onboardLEDs.setPixelColor(1, neonLEDs.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + 20) * 100)));
      onboardLEDs.setPixelColor(2, neonLEDs.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + 30) * 100)));
      onboardLEDs.setPixelColor(3, neonLEDs.Color(255, 0, 50 + (sin((sine_offset / sine_ms) + 40) * 100)));
    // }
    sine_offset += ms_elapsed;
    if (sine_offset > TWO_PI * sine_ms) {
      sine_offset -= TWO_PI * sine_ms;
    }
  } else if (shieldMode == BLUE_GREEN) {
    for (uint8_t i = 0; i < NUM_NEON; i++) {
      neonLEDs.setPixelColor(i, neonLEDs.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + (i)) * 100)));
    }
    onboardLEDs.setPixelColor(0, neonLEDs.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + 10) * 100)));
    onboardLEDs.setPixelColor(1, neonLEDs.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + 20) * 100)));
    onboardLEDs.setPixelColor(2, neonLEDs.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + 30) * 100)));
    onboardLEDs.setPixelColor(3, neonLEDs.Color(0, 255, 50 + (sin((sine_offset / sine_ms) + 40) * 100)));
    sine_offset += ms_elapsed;
    if (sine_offset > TWO_PI * sine_ms) {
      sine_offset -= TWO_PI * sine_ms;
    }
  } else if (shieldMode == CYLON) {
    for (uint8_t i = 0; i < NUM_NEON; i++) {
      if (i == cylon) {
        neonLEDs.setPixelColor(i, neonLEDs.Color(255, 0, 0));
      } else {
        neonLEDs.setPixelColor(i, neonLEDs.Color(0, 0, 0));
      }
    }
    onboardLEDs.setPixelColor(0, neonLEDs.Color(255, 0, 0));
    onboardLEDs.setPixelColor(1, neonLEDs.Color(255, 0, 0));
    onboardLEDs.setPixelColor(2, neonLEDs.Color(255, 0, 0));
    onboardLEDs.setPixelColor(3, neonLEDs.Color(255, 0, 0));
    for (uint16_t x = 0; x < 4; x++) {
      for (uint16_t y = 0; y < 4; y++) {
        uint16_t i = (y * 4) + x;
        if (i == cylon) {
          trellis.pixels.setPixelColor(i, neonLEDs.Color(255, 0, 0));
        } else {
          trellis.pixels.setPixelColor(i, neonLEDs.Color(0, 0, 0));
        }
      }
    }
    cylon += 1;
    if (cylon > NUM_NEON) {
      cylon = 0;
    }
  } else if (shieldMode == AUDIT) {
    // Audit mode (for counting & finding LED positions IRL)
    // Every neon strand a different color, with every odd pixel on
    for (uint8_t r = 0; r < 8; r++) { // For each strand...
      for (int p = 0; p < NUM_LED; p++) { // For each pixel of strand...
        uint8_t pn = r * NUM_LED + p;
        neonLEDs.setPixelColor(pn, neonLEDs.ColorHSV(r * 6000, 255, (p % 2) * 255));
      }
    }
  } else if (shieldMode == COORD_TEST) {
    // COORD TEST / PLAID
    for (uint8_t i = 0; i < NUM_NEON; i++) {
      float dist_x = abs(coordTest_x - neonLEDs_x[i]);
      float dist_y = abs(coordTest_y - neonLEDs_y[i]);
      float dist_z = abs(coordTest_z - neonLEDs_z[i]);
      uint8_t r = 0;
      uint8_t g = 0;
      uint8_t b = 0;
      if (dist_x < 40.0) {
        r = 255;
      }
      if (dist_y < 50.0) {
        b = 255;
      }
      if (dist_z < 50.0) {
        g = 255;
      }
      neonLEDs.setPixelColor(i, neonLEDs.Color(r, g, b));
    }
    for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
      float dist_x = abs(coordTest_x - dotstarLEDs_x[i]);
      float dist_y = abs(coordTest_y - dotstarLEDs_y[i]);
      float dist_z = abs(coordTest_z - dotstarLEDs_z[i]);
      uint8_t r = 0;
      uint8_t g = 0;
      uint8_t b = 0;
      if (dist_x < 20.0) {
        r = 55;
      }
      if (dist_y < 50.0) {
        b = 55;
      }
      if (dist_z < 50.0) {
        g = 55;
      }
      dotstars.setPixelColor(i, dotstars.Color(g, r, b)); // Dotstars are GRB
    }
    coordTest_x += ms_elapsed / 1.2;
    coordTest_y += ms_elapsed / 2.0;
    coordTest_z += ms_elapsed / 20.0;

    if (coordTest_x > neonLEDs_xMax) {
      coordTest_x -= neonLEDs_xMax;
    }
    if (coordTest_y > neonLEDs_yMax) {
      coordTest_y -= neonLEDs_yMax;
    }
    if (coordTest_z > neonLEDs_zMax) {
      coordTest_z = neonLEDs_zMin;
    }
  } else if (shieldMode == BORING_MODE) {
    // BORING MODE
    for (uint8_t r = 0; r < 8; r++) { // For each strand...
      for (int p = 0; p < NUM_LED; p++) { // For each pixel of strand...
        uint8_t pn = r * NUM_LED + p;
        if (r == 1) { // Brake Lights
          if (p > 6 && p < 10) {
            neonLEDs.setPixelColor(pn, neonLEDs.Color(255, 0, 0));
          } else {
            neonLEDs.setPixelColor(pn, neonLEDs.Color(55, 0, 0));
          }
        } else if (r == 7) { // Nav lights
          if (p == 0) {
            neonLEDs.setPixelColor(pn, neonLEDs.Color(255, 0, 0));
          } else if (p == 12) {
            neonLEDs.setPixelColor(pn, neonLEDs.Color(0, 255, 0));
          } else {
            neonLEDs.setPixelColor(pn, 0);
          }
        } else {
          neonLEDs.setPixelColor(pn, 0);
        }
      }
    }
    // Headlights TODO: subtle gradient?
    for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
      uint16_t y = i % 144;
      if (y > 120) {
        uint8_t brightness = y - 120;
        dotstars.setPixelColor(i, dotstars.ColorHSV(30000, 10, brightness));
      } else {
        dotstars.setPixelColor(i, 0);
      }
    }
  } else {
    // RANDOM RAINBOWS by default
    for (uint8_t i = 0; i < NUM_NEON; i++) {
      neonLEDs.setPixelColor(i, Wheel(((millis() / 200) + i) * 3.5));
    }
    // Onboard orange by default
    onboardLEDs.setPixelColor(0, 70, 30, 0);
    onboardLEDs.setPixelColor(1, 70, 30, 0);
    onboardLEDs.setPixelColor(2, 70, 30, 0);
    onboardLEDs.setPixelColor(3, 70, 30, 0);
    // Trellis off by default
    for (uint16_t i = 0; i < trellis.pixels.numPixels(); i++) {
      trellis.pixels.setPixelColor(i, 0, 0, 0);
    }
  }

  // TURN SIGNALS
  if (turnSignalState != OFF) {
    float speed = 200.0;
    if (turnSignalState == STARBOARD) {
      speed = speed * -1.0;
    }
    for (uint8_t i = 0; i < NUM_NEON; i++) {
      float pulseSin = sin((neonLEDs_z[i] / 100.0) + (millis() / speed));
      bool pulse;
      if (turnSignalState == LEFT) {
        pulse = pulseSin > 0 && neonLEDs_z[i] < 20;
      } else {
        pulse = pulseSin > 0 && neonLEDs_z[i] > -20;
      }
      // Serial.println(pulseSin);
      if (pulse) {
        neonLEDs.setPixelColor(i, neonLEDs.Color(255, 215, 1));
        if (i == 28) { // Sample pixel 28, which is centered (rear)
          if (turnSignalState == LEFT) {
            trellis.pixels.setPixelColor(12, neonLEDs.Color(255, 215, 1));
          } else {
            trellis.pixels.setPixelColor(13, neonLEDs.Color(255, 215, 1));
          }
        }
      } else if (i == 28) {
        trellis.pixels.setPixelColor(12, 0);
        trellis.pixels.setPixelColor(13, 0);
      }
    }
  }  

  if (isDown[15]) {
    // *** 100% White Flash 0.o ***
    for (uint8_t i = 0; i < NUM_NEON; i++) {
      neonLEDs.setPixelColor(i, neonLEDs.Color(255, 255, 255));
    }
    for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
      dotstars.setPixelColor(i, neonLEDs.Color(255, 255, 255));
    }
  }


  dotstars.show();
  // if (shieldMode != 4 || shieldModeWas != 4) {
    onboardLEDs.show();
    trellis.pixels.show(); 
    neonLEDs.show(); // It seems important that be last to avoid random flickering!? DMA side effect?
  // }

  float fade = ms_elapsed / 4.0;
  for (uint16_t i = 0; i < sizeof(sparkles_r); i++) {
    if (sparkles_r[i] - fade > 0) {
      sparkles_r[i] -= fade;
    } else {
      sparkles_r[i] = 0;
    }
    if (sparkles_g[i] - fade > 0) {
      sparkles_g[i] -= fade;
    } else {
      sparkles_g[i] = 0;
    }
    if (sparkles_b[i] - fade > 0) {
      sparkles_b[i] -= fade;
    } else {
      sparkles_b[i] = 0;
    }
  }

  // displayAccelerometer(); // This causes glitching in some neon pixels (DMA?), and seems slow as well.

  msSinceNeoPixelPush = 0;
  millis_last = millis();
  shieldModeWas = shieldMode; // Is this the best was to selectivly pause the loop for some LEDs?

  // if (shieldMode != 4 || shieldModeWas != 4) {
    delay(16); // the trellis has a resolution of around 60hz
  // } else {
  //   delay(1);
  // }
}

void dotstarSparkleParty() {
  if (random(60) < ms_elapsed) {
    dotstarSparksHue[dotstarSparksNext] = random(MAX16BIT);
    dotstarSparksAtk[dotstarSparksNext] = 0.0;
    dotstarSparksTTL[dotstarSparksNext] = 1000 + random(600);
    dotstarSparksPos[dotstarSparksNext] = random(MAX16BIT);
    dotstarSparksVel[dotstarSparksNext] = random(12) / 1.0; - 50.0; //- (dotstarMaxVel / 2.0);
    dotstarSparksAcc[dotstarSparksNext] = random(0.2 * 100.0) / 100.0 + 1.2;
    dotstarSparksNext++;
    if (dotstarSparksNext >= DOTSTARSPARKS) {
      dotstarSparksNext = 0;
    }
  }

  for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
    dotstarR[i] = 0;
    dotstarG[i] = 0;
    dotstarB[i] = 0;
  }
  for (uint16_t s = 0; s < DOTSTARSPARKS; s++) {
    if (dotstarSparksPos[s]) {
      float pos = ((dotstarSparksPos[s] / 65535.0) * NUMDOTSTARS);
      for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
        float distance = abs(pos - i);
        if (distance < 5) { // TODO: Variable sizes?
          float val = 255; // Bright flickery centers
          if (distance > 0.01) {
            val = 96.0 * (5.0 - distance) / 5.0; // Distance from spark position
          }
          val = val * dotstarSparksAtk[s]; // Fade-in (attack)
          if (dotstarSparksTTL[s] < 1000) {
            val = val * (dotstarSparksTTL[s] / 1000.0); // Fade-out (TTL)
          }                
          uint32_t rgbcolor = dotstars.ColorHSV(dotstarSparksHue[s], 255, uint8_t(val));
          dotstarR[i] += getRedValueFromColor(rgbcolor);
          dotstarG[i] += getGreenValueFromColor(rgbcolor);
          dotstarB[i] += getBlueValueFromColor(rgbcolor);
        }
      }
      if (dotstarSparksPos[s] + dotstarSparksVel[s] * ms_elapsed < 0) {
        dotstarSparksPos[s] += dotstarSparksVel[s] * ms_elapsed + MAX16BIT;
      } else if (dotstarSparksPos[s] + dotstarSparksVel[s] * ms_elapsed > MAX16BIT) {
        dotstarSparksPos[s] += dotstarSparksVel[s] * ms_elapsed - MAX16BIT;
      } else {
        dotstarSparksPos[s] += dotstarSparksVel[s] * ms_elapsed;
      }

      dotstarSparksVel[s] += dotstarSparksAcc[s];
      if (dotstarSparksAtk[s] < 1) {
        dotstarSparksAtk[s] = min(dotstarSparksAtk[s] + (0.001 * ms_elapsed), 1);
      }
      if (dotstarSparksTTL[s] > 0) {
        dotstarSparksTTL[s] = max(dotstarSparksTTL[s] - ms_elapsed, 0);
      }
    }
  }
  for (uint16_t i = 0; i < NUMDOTSTARS; i++) {
    dotstars.setPixelColor(i, dotstars.Color(dotstarR[i], dotstarG[i], dotstarB[i]));
  }
}

uint32_t Wheel(byte WheelPos)
{
  WheelPos = 255 - (WheelPos % 255);
  if (WheelPos < 85)
  {
    return neonLEDs.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  }
  else if (WheelPos < 170)
  {
    WheelPos -= 85;
    return neonLEDs.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  }
  else
  {
    WheelPos -= 170;
    return neonLEDs.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
  }
}

void testdrawtext(char *text, uint16_t color) {
  tft.setCursor(0, 0);
  tft.setTextColor(color);
  tft.setTextWrap(true);
  tft.print(text);
}


// Input a value 0 to 255 to get a color value.
// The colors are a transition r - g - b - back to r.
uint32_t TrellisWheel(byte WheelPos) {
  if (WheelPos < 85) {
    return trellis.pixels.Color(WheelPos * 3, 55 - WheelPos * 3, 0);
  } else if (WheelPos < 170) {
    WheelPos -= 85;
    return trellis.pixels.Color(55 - WheelPos * 3, 0, WheelPos * 3);
  } else {
    WheelPos -= 170;
    return trellis.pixels.Color(0, WheelPos * 3, 55 - WheelPos * 3);
  }
  return 0;
}

// Accelerometer
#include <Wire.h>
#include <Adafruit_MSA301.h>
#include <Adafruit_Sensor.h>
Adafruit_MSA301 msa;

void initAccelerometer() {
 // Try to initialize MSA301
  if (! msa.begin()) {
    Serial.println("Failed to find MSA301 chip");
    while (1) {
      delay(10);
    }
  }
  Serial.println("MSA301 Found!");
  //msa.setDataRate(MSA301_DATARATE_31_25_HZ);
  Serial.print("Data rate set to: ");
  switch (msa.getDataRate()) {
    case MSA301_DATARATE_1_HZ: Serial.println("1 Hz"); break;
    case MSA301_DATARATE_1_95_HZ: Serial.println("1.95 Hz"); break;
    case MSA301_DATARATE_3_9_HZ: Serial.println("3.9 Hz"); break;
    case MSA301_DATARATE_7_81_HZ: Serial.println("7.81 Hz"); break;
    case MSA301_DATARATE_15_63_HZ: Serial.println("15.63 Hz"); break;
    case MSA301_DATARATE_31_25_HZ: Serial.println("31.25 Hz"); break;
    case MSA301_DATARATE_62_5_HZ: Serial.println("62.5 Hz"); break;
    case MSA301_DATARATE_125_HZ: Serial.println("125 Hz"); break;
    case MSA301_DATARATE_250_HZ: Serial.println("250 Hz"); break;
    case MSA301_DATARATE_500_HZ: Serial.println("500 Hz"); break;
    case MSA301_DATARATE_1000_HZ: Serial.println("1000 Hz"); break;
  }

  //msa.setPowerMode(MSA301_SUSPENDMODE);
  Serial.print("Power mode set to: ");
  switch (msa.getPowerMode()) {
    case MSA301_NORMALMODE: Serial.println("Normal"); break;
    case MSA301_LOWPOWERMODE: Serial.println("Low Power"); break;
    case MSA301_SUSPENDMODE: Serial.println("Suspend"); break;
  }

  //msa.setBandwidth(MSA301_BANDWIDTH_31_25_HZ);
  Serial.print("Bandwidth set to: ");
  switch (msa.getBandwidth()) {
    case MSA301_BANDWIDTH_1_95_HZ: Serial.println("1.95 Hz"); break;
    case MSA301_BANDWIDTH_3_9_HZ: Serial.println("3.9 Hz"); break;
    case MSA301_BANDWIDTH_7_81_HZ: Serial.println("7.81 Hz"); break;
    case MSA301_BANDWIDTH_15_63_HZ: Serial.println("15.63 Hz"); break;
    case MSA301_BANDWIDTH_31_25_HZ: Serial.println("31.25 Hz"); break;
    case MSA301_BANDWIDTH_62_5_HZ: Serial.println("62.5 Hz"); break;
    case MSA301_BANDWIDTH_125_HZ: Serial.println("125 Hz"); break;
    case MSA301_BANDWIDTH_250_HZ: Serial.println("250 Hz"); break;
    case MSA301_BANDWIDTH_500_HZ: Serial.println("500 Hz"); break;
  }

  //msa.setRange(MSA301_RANGE_2_G);
  Serial.print("Range set to: ");
  switch (msa.getRange()) {
    case MSA301_RANGE_2_G: Serial.println("+-2G"); break;
    case MSA301_RANGE_4_G: Serial.println("+-4G"); break;
    case MSA301_RANGE_8_G: Serial.println("+-8G"); break;
    case MSA301_RANGE_16_G: Serial.println("+-16G"); break;
  }

  //msa.setResolution(MSA301_RESOLUTION_14 );
  Serial.print("Resolution set to: ");
  switch (msa.getResolution()) {
    case MSA301_RESOLUTION_14: Serial.println("14 bits"); break;
    case MSA301_RESOLUTION_12: Serial.println("12 bits"); break;
    case MSA301_RESOLUTION_10: Serial.println("10 bits"); break;
    case MSA301_RESOLUTION_8: Serial.println("8 bits"); break;
  }
}

int8_t accelerationXMax = 0;
int8_t accelerationXMin = 0;
int8_t accelerationYMax = 0;
int8_t accelerationYMin = 0;
int8_t accelerationZMax = 0;
int8_t accelerationZMin = 0;
void displayAccelerometer() {
  /* Display the results (acceleration is measured in m/s^2) */
  sensors_event_t event;
  msa.getEvent(&event);
  accelerationXMax = max(accelerationXMax, event.acceleration.x);
  accelerationXMin = min(accelerationXMin, event.acceleration.x);
  accelerationYMax = max(accelerationYMax, event.acceleration.y);
  accelerationYMin = min(accelerationYMin, event.acceleration.y);
  accelerationZMax = max(accelerationZMax, event.acceleration.z);
  accelerationZMin = min(accelerationZMin, event.acceleration.z);

  tft.setTextSize(2);
  tft.setCursor(0, 10);
  tft.setTextColor(ST77XX_ORANGE_DK, ST77XX_BLACK);
  tft.print("x");
  tft.setTextColor(ST77XX_ORANGE_RED, ST77XX_BLACK);
  tft.print(event.acceleration.x);

  tft.setCursor(80, 10);
  tft.setTextColor(ST77XX_ORANGE_DK, ST77XX_BLACK);
  tft.print("y");
  tft.setTextColor(ST77XX_ORANGE_RED, ST77XX_BLACK);
  tft.print(event.acceleration.y);

  tft.setCursor(160, 10);
  tft.setTextColor(ST77XX_ORANGE_DK, ST77XX_BLACK);
  tft.print("z");
  tft.setTextColor(ST77XX_ORANGE_RED, ST77XX_BLACK);
  tft.print(event.acceleration.z);

  // Show min/max acceleration
  tft.setTextSize(1);
  tft.setTextColor(ST77XX_ORANGE_DK, ST77XX_BLACK);
  tft.setCursor(0, 29);
  tft.print(accelerationXMin);
  tft.print(" | ");
  tft.print(accelerationXMax);

  tft.setCursor(80, 29);
  tft.print(accelerationYMin);
  tft.print(" | ");
  tft.print(accelerationYMax);

  tft.setCursor(160, 29);
  tft.print(accelerationZMin);
  tft.print(" | ");
  tft.print(accelerationZMax);
}


// Ring buffer for console output
uint8_t consoleLines = 8;
String consoleBuffer[8];
uint8_t consolePointer = 0;
void drawConsole(String string) {
  Serial.println(string);
  consoleBuffer[consolePointer] = string;
  consolePointer = (consolePointer + 1) % 8;
  tft.setCursor(0, 90);
  tft.setTextSize(1);
  tft.setTextWrap(false);
  tft.setTextColor(ST77XX_ORANGE, ST77XX_BLACK);
  for (uint16_t i = 0; i < 8; i++) {
    tft.println(consoleBuffer[(i + consolePointer) % 8] + "                    "); // Dumb right pad
  }
}


uint8_t getRedValueFromColor(uint32_t c) {
  return c >> 16;
}
uint8_t getGreenValueFromColor(uint32_t c) {
    return c >> 8;
}
uint8_t getBlueValueFromColor(uint32_t c) {
    return c;
}


// Compute the dot product AB . BC
double DotProduct(double pointA[2], double pointB[2], double pointC[2])
{
    double ab[2];
    double bc[2];
    ab[0] = pointB[0] - pointA[0];
    ab[1] = pointB[1] - pointA[1];
    bc[0] = pointC[0] - pointB[0];
    bc[1] = pointC[1] - pointB[1];
    double dot = ab[0] * bc[0] + ab[1] * bc[1];

    return dot;
}

// Compute the cross product AB x AC
double CrossProduct(double pointA[2], double pointB[2], double pointC[2])
{
    double ab[2];
    double ac[2];
    ab[0] = pointB[0] - pointA[0];
    ab[1] = pointB[1] - pointA[1];
    ac[0] = pointC[0] - pointA[0];
    ac[1] = pointC[1] - pointA[1];
    double cross = ab[0] * ac[1] - ab[1] * ac[0];

    return cross;
}
// Compute the distance from A to B
double Distance(double pointA[2], double pointB[2])
{
    double d1 = pointA[0] - pointB[0];
    double d2 = pointA[1] - pointB[1];

    return sqrt(d1 * d1 + d2 * d2);
}

// Compute the distance from AB to C
// if isSegment is true, AB is a segment, not a line.
double LineToPointDistance2D(double pointA[2], double pointB[2], double pointC[2], bool isSegment)
{
    double dist = CrossProduct(pointA, pointB, pointC) / Distance(pointA, pointB);
    if (isSegment)
    {
        double dot1 = DotProduct(pointA, pointB, pointC);
        if (dot1 > 0)
            return Distance(pointB, pointC);

        double dot2 = DotProduct(pointB, pointA, pointC);
        if (dot2 > 0)
            return Distance(pointA, pointC);
    }
    // return abs(dist);
    return dist;
}

float easeInCirc(float x) {
  return 1 - sqrt(1 - pow(x, 2));
}
float easeOutCirc(float x) {
  return sqrt(1 - pow(x - 1, 2));
}
